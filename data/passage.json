{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1783039605524660226",
        "title": "奇安信的年终奖，出乎了所有人意料！（给目标进大厂同学的建议）",
        "description": null,
        "content": "大家好，我是程序员鱼皮。\n\n来吃个瓜，昨天看到了这么一条热搜消息，号称网安一哥的大厂奇安信官宣 “全员无年终奖”！\n\n![](https://pic.yupi.icu/1/2ebe2624f1dabfc9ddcf1ce15fd2d968.jpeg)\n\n不知道这算不算刷新了大厂的记录，上有王者荣耀团队百月年终，下有网安大厂全员无年终。同样是在大厂打工，薪资差距真的也可以有天壤之别！\n\n说实在的，如果我是奇安信的员工，想必也是愤怒到极点了吧，希望大厂都能振作起来，让国内的环境回暖一些。\n\n说到这里，其实我也想做个小调研，对于刚毕业的同学来说，你会更倾向于选择薪资更高的小公司，还是规模更大、技术更先进的大公司呢？\n\n（放投票）\n\n如果让鱼皮来选择，刚毕业的时候可能还是会进大厂吧。虽然我自己也在创业开小公司，但很多其他小公司的技术同学就是在打杂，能学到的东西可能是有限的。\n\n前段时间我收到 [编程导航](https://mp.weixin.qq.com/s/AjD2dKA5br0htPo1iqzkBQ) 一位同学的提问，这位同学目标就非常坚定： **我就是要进国内大厂，非大厂不进！**\n\n针对这种情况，下面鱼皮给同学们一些学习建议，可供参考。\n\n\n\n## 鱼友提问\n\n先简单介绍下这位同学的情况：\n\n1）技术栈（Java 后端方向）：\n\n- 计算机基础： 有算法基础，力扣做了 300 题左右，网络、操作系统、数据库本科学过，不够深入且不知道如何深入需要到什么程度才有掌控感。语言基础：JVM 刚开始。设计基础：主要通过阅读源码进行设计能力的提升，源码刚开始。\n- 项目和框架：到 SpringBoot 做过两个前后端的项目（前端用 vue，后端 springboot），springcloud 在学习中。但是感觉没有看到太多应用场景，没有很找到学习这个技术的需求，所以有点迷茫。\n\n2）实习经历：一个小厂后端 + 一个百强企业 AI 方向实习\n\n3）具体需求：\n\n- 参加秋招，冲击国内大厂，且只要大厂！\n- 计算机基础感觉掌握地并不牢固，想知道怎么提升这一块？\n- 语言 JVM 以及设计源码的这些核心内功，不知道怎么深入学习？\n\n取其上者得其中，我想得到一个比较高的标准和策略，一定严格执行。每天差不多能拿出 4 - 5 个小时左右的时间来学习，周末和假期可以 10 个小时以上学习。假期比较多，可以塞满。\n\n\n\n## 鱼皮回答\n\n这个问题非常大，但也非常好，针对学历还不错（一本及以上）、想进大厂且只进大厂的同学，我可以给出如下建议。\n\n> 学历一般的同学，我的建议是不要把自己局限于某规模的公司，还是尽量多投递、多争取机会再做选择。\n\n\n\n#### 1、进大厂的门槛：简历\n\n简历是进大厂的基础关和门槛，简历上的核心内容就是专业技能、项目和其他经历。\n\n专业技能大家写得都差不多，只要认真按照 [编程导航](https://mp.weixin.qq.com/s/AjD2dKA5br0htPo1iqzkBQ) 的 [写简历技巧文档](https://bcdh.yuque.com/staff-wpxfif/resource/yvtiza4dmgumk3dt) 优化即可，不必多说。\n\n实习经历和项目经历是进大厂的关键，这位同学已经有 2 段实习经历，只要表达清楚每段实习的工作和关键成果、能和求职的目标岗位（Java 后端）有一定关联就足够了。\n\n最能发挥的还是项目经历，尤其是要自己做项目，必须要在跟编程导航或者网上的教程完成项目的前提下，做一些换皮和扩展，拉开区分度。\n\n比如看看优秀鱼友对鱼皮智能 BI 项目的扩展，增加了很多有意思的新功能：\n\n![](https://pic.yupi.icu/1/output%20(4).png)\n\n如果想稳进大厂，可以有这样一个策略：拿自己的简历去对标工作 1 - 3 年经验的简历，如果感觉项目经历差不多，那么希望很大。\n\n\n\n#### 2、进大厂的关键：项目经验和系统设计能力\n\n大厂需要的是有能力应对挑战的高手。所以一般在大厂面试中，都会有场景类、系统设计类的问题，比如让你设计一个实时弹幕系统，这些问题能够看出候选人的能力上限。水平差的人可能只知道用数据库存弹幕，高手则能够利用 Redis 等各种中间件、从前端到后端设计出一整套高性能的系统。这个时候，你到底是背书的、还是真正有经验的，一问便知，所以只靠背八股文是不行的。\n\n所以如何提高自己的上限？接下来的时间应该投入在哪里呢？\n\n首先在技术学习上，大厂必备的后端技能一样不能拉下，优先把我的 [Java 后端学习路线](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247559154&idx=1&sn=8c12b037854cb347f383abf1f0a3ea71&chksm=e9c30005deb4891346cafa4bdb30e47172f0cb9f8afea22e6a137731bd9825f01d6e6b136653&token=909345065&lang=zh_CN#rd) 第四阶段技能全部学完，并且重点是：**一定要运用到项目中，加深理解。**\n\n我不是很建议 “通过阅读源码提升设计能力”，因为在你自身项目经验并不丰富、编码能力并不强的时候（比如还不会运用设计模式到项目中），看源码的性价比很低。一方面是效率低，另一方面是不容易吸收，毕竟 “看懂代码” 和 “能自己写出来” 还是有很大的鸿沟的。\n\n所以我建议还不能熟练根据需求设计方案和完成项目的同学，优先把 80% 以上的时间投入到项目上。按照 [鱼皮项目学习建议](https://yuyuanweb.feishu.cn/wiki/Q4AdwjLDWiLZy0kAjHqcQinon8N) 中的顺序，把几个项目的后端学完、自己写出代码并上线（先只做后端，前端可完全跳过）。\n\n![鱼皮项目学习建议](https://pic.yupi.icu/1/image-20240411131942324.png)\n\n不要觉得自己之前已经有项目经验就不看了，如果你真的很熟悉某些技术的运用，那么可以快进或者跳着看。时间紧急的话，甚至可以只看需求分析部分，能自主设计出方案即可，代码都不用写了，从而快速锻炼自己的系统设计能力。\n\n对于这位同学，每天平均投入 6 个小时、再加上之前有做过项目的前提下，一个月内应该可以完成 5  - 6 个项目，这是针对目标只进大厂的高要求，其他同学不必对此感到有压力。\n\n当你认为自己已经能够熟练运用大多数技术来设计实现方案的时候，再去阅读源码，你学到的就不只是 “背八股文、背了一套解决方案”，而是能和自己之前的项目经验融会贯通，真正理解前人设计的精妙之处。\n\n所有新技术的学习都可以遵循 [我的技术学习建议路线](https://bcdh.yuque.com/staff-wpxfif/resource/nxkhhu) ，找到工作前大多数技术能够做到第 4 阶段（主动运用），有 1 - 2 个技术达到第 5 - 6 阶段（了解原理和深入源码）就已经非常优秀了。\n\n![](https://pic.yupi.icu/1/image-20240411132144690.png)\n\n\n\n#### 3、进大厂的及格线：基本功\n\n想进大厂，必须要有足够高的上限，当然，下限也不能太低。计算机基础和八股文之类的基本功，就是进大厂的下限，是必须要准备的。\n\n除了做项目之外，建议剩下 20% 的时间每天坚持背八股文、继续刷算法。\n\n对于学习计算机网络和操作系统，如果你之前完全没学过相关的课程，只需要背八股文就可以了；尤其对于学习能力强的同学，不需要系统看教程（尤其是像什么黑皮书之类的），比较费时间、性价比不高，因为八股文无非就那些题目，全都能理解透了也能掌握个 70 - 80%，足够应付面试。\n\n> 当然，如果你现在才大一大二，时间丰富，有空多去看看计算机基础的系统教程，肯定更加分。\n\n背八股文的过程中必须要做的一件事：整理自己的八股文手册。对题目进行分类整理，并且每道题目在别人答案的基础上，给出自己的思考和答案，这样印象会更深刻，整体效率也会更高。\n\n做每日计划这点就不多说了，建议大家平时多阅读网上程序员相关的文章，提升自己的软技能也很重要。\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 52,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-24 15:45:43",
        "updateTime": "2024-04-28 08:45:52",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3085,
          "coin": 170,
          "followeeNum": 1488,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-21 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-04-28 01:02:16"
        },
        "tags": [
          "文章",
          "求职",
          "学习建议"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1782694682812219393",
        "title": "我们做的小工具上线啦！（剪切助手上线）",
        "description": null,
        "content": "大家好，我是程序员鱼皮。\n\n好消息，好消息，我们的新产品又又又又上线啦！\n\n这次，我们做的是一款桌面端软件，号称 “颜值天花板” 的超级剪切板工具 `《剪切助手》`。\n\n> 官网下载：[https://jianqiezhushou.com](https://jianqiezhushou.com/)\n\n![](https://pic.yupi.icu/1/1713409268242-4c2f1edd-7d80-4d04-8f05-0a553f3ee12a.png)\n\n\n\n这也是我第一次正式发布桌面端软件。老实说，我们从去年就开始规划这个产品了，过程中踩了很多坑，快把我们团队开发折磨秃了。。。\n\n\n\n## 为什么做这个项目？\n\n首先肯定是从我自己的需求出发了，作为一名程序员和知识创作者，在我写文章和代码时，需要频繁地复制和粘贴多段内容，比如把不同文件的部分代码统一粘贴到文章内。\n\n但无奈的是，系统默认只支持粘贴最近一次复制的内容，如果想找到之前已经复制的内容并再次粘贴，就很麻烦，只能再去复制一次。\n\n![](https://pic.yupi.icu/1/1713416385991-eb2223b9-88cc-4342-b871-0f957c2ad8d0.gif)\n\n我们团队的运营同学也有类似的烦恼：在回复用户时，往往要频繁回复同样的话术；每次回复时，都需要从备忘录里找到对应的内容，再来回地复制粘贴。\n\n![](https://pic.yupi.icu/1/1713417097466-d12e4309-1f96-4915-8f92-92fdb682d464.gif)\n\n有没有办法提高我们的工作效率呢？\n\n答案：选用一个能力更强的剪切板工具。\n\n\n\n其实很早之前我就有用过一些剪切板工具，也调研了近十个剪切板工具，无奈它们都无法满足我的需求。\n\n比如有的剪切板工具不支持搜索：\n\n![](https://pic.yupi.icu/1/1712630529534-e9b3ae7f-fdc2-4a96-9e3a-35bbe3bf4705.png)\n\n\n\n有的剪切板工具只能复制纯文本，甚至不支持保存文件的复制记录：\n\n![](https://pic.yupi.icu/1/1712632112480-4ef3d96a-30ad-4451-b458-d065b4a8d099.png)\n\n\n\n而且他们的界面大多都不够优雅，比如这样：\n\n![](https://pic.yupi.icu/1/1713410231149-602d7673-1971-4a42-8ecc-9c85893b6073.png)\n\n\n\n我相信尤其是对于程序员朋友们，应该非常追求软件的美观炫酷吧。\n\n此外，我发现大多数剪切板工具都是 **本地的**。自己在某台电脑上复制的内容无法同步到其他的设备。一旦更换了设备，之前已复制的内容便全部丢失了！\n\n当然，也有一些相对好用的剪切板工具，但几乎都是收费的。。。\n\n于是，我们决定自己出手了！ **剪切助手，启动！**\n\n\n\n## 什么是剪切助手？\n\n剪切助手是一款界面精美、简单易用、跨设备同步、功能丰富的超级剪切板工具，目标是帮助大家大幅提高工作效率。\n\n> 官网下载：[https://jianqiezhushou.com](https://jianqiezhushou.com/)\n\n![](https://pic.yupi.icu/1/1713411132983-066edaac-17e1-4aeb-902f-a0d0bc2e2a75.png)\n\n\n\n产品支持 Windows 和 Mac 双系统，且核心功能 **完全免费**！不就是白票嘛，拿去拿去~\n\n![](https://pic.yupi.icu/1/1713410772603-7e592934-bc29-49ac-a91f-7c7520d58584.png)\n\n\n\n下面只用一分钟，带大家快速掌握这款提高效率神器的用法（文末还有福利哦 \uD83C\uDF81）！\n\n\n\n### 一、颜值天花板\n\n我们精心设计了剪切助手的 UI 界面，可以说是同类软件中的颜值天花板，就是这么自信~\n\n咱就是说，光是看这个 Logo，就让我想起了一位故人。。\n\n![](https://pic.yupi.icu/1/1712573250998-5f2b3ede-30dc-4baa-b1cd-62ef2ddc7cd7.png)\n\n\n\n剪切助手支持横向布局和纵向布局，可以自由切换，灵活地展示已复制的内容：\n\n![](https://pic.yupi.icu/1/1712632997742-76c75db3-5636-4709-88fd-47f0fb688034-20240418132647846.png)\n\n![](https://pic.yupi.icu/1/1712575500228-ef068c26-a873-4957-b734-fafb36a580e9.png)\n\n\n\n同时剪切助手提供了深色模式和浅色模式，可以根据自己的需要切换主题：\n\n![](https://pic.yupi.icu/1/1712575739455-862a167e-4280-4d9d-a396-364ff0cb66fd.png)\n\n\n\n### 二、高效搜索粘贴\n\n剪切助手非常简单易用，只需要正常地按 `Ctrl + C` 进行复制，然后按快捷键（默认是 `Ctrl + O`）就可以唤起已复制内容面板。\n\n无需使用鼠标，通过按键就可以自由搜索和选择内容进行粘贴：\n\n![](https://pic.yupi.icu/1/1712643297334-792ddd3d-cabe-4e30-8f89-0cfd67c7f248.png)\n\n\n\n还可以对内容进行分组，便于快速筛选，比如鱼皮将常用的代码片段分到了一组：\n\n![](https://pic.yupi.icu/1/1713415283996-519e13e9-b867-4f9a-b74f-7e7f8937c348.png)\n\n\n\n利用分组功能，你完全可以把剪切助手当做一个备忘录来使用，将自己要做的事情拖入指定分组，一目了然：\n\n![](https://pic.yupi.icu/1/1713417204516-b434ed8f-ccce-4c4f-94a2-97419ab8b691.png)\n\n\n\n还有更高效的用法！只需按 `Ctrl + 数字键`，就可以按顺序粘贴最新复制的几个内容，图片和文件等内容也可以快速粘贴到文件夹中~\n\n![](https://pic.yupi.icu/1/1712814806558-0d9c7546-bcc6-4897-a072-35275bb69a15.gif)\n\n\n\n### 三、自定义快捷键\n\n剪切助手还支持自定义快捷键，实现快速切换分组、粘贴最近复制的内容。\n\n甚至还支持给指定内容设置快捷键，可以一键粘贴自己最常用的内容：\n\n![](https://pic.yupi.icu/1/1712576413168-7e2614bb-e180-4cec-b442-46dbfff5f31a.png)\n\n\n\n运营同学可以利用这个功能，给一些高频回复的话术设置快捷键。在需要回复时，按下对应的快捷键即可，不用再去翻备忘录了！\n\n\n\n### 四、极速分享内容\n\n这是其他市面上的剪切板工具没有的创新功能，可以一键分享自己复制的内容。\n\n例如我要分享一个有趣的字符画，只需要右键单击内容，就会得到一个分享链接：\n\n> 比如：http://web.jianqiezhushou.com/post/348983238094074\n\n![](https://pic.yupi.icu/1/1712576116576-c34dfd98-19ce-40b7-b25b-4c2f13fd41c6.png)\n\n\n\n然后自己和其他小伙伴就可以在任意设备上查看分享的内容，如下图：\n\n![](https://pic.yupi.icu/1/1713416065657-0adddd2c-242c-47ad-8929-83c7f65ce45a.png)\n\n\n\n所以完全可以把剪切助手当做一个信息同步的小工具，比如把自己电脑上复制的代码分享到手机上查看等~\n\n\n\n### 五、跨设备云同步\n\n剪切助手提供了云同步功能，支持多台设备共享复制内容。\n\n比如你在 Windows 电脑上复制的内容，想换到一台 Mac 新电脑，只需要点击同步按钮，就能无缝切换、快速完成同步备份，数据不会丢失！\n\n![](https://pic.yupi.icu/1/1712576546395-c47fb4ee-98fd-45ff-b0bd-3fa42dc3a1d9.png)\n\n云同步默认不会开启，所以大家完全不用担心隐私问题。\n\n\n\n### 其它功能\n\n除了上述核心功能，我们还提供了很多比较细节的功能。\n\n比如：**自动识别复制的内容类别**\n\n如果复制的内容是链接，会展示网页标题和 logo，并且右键单击就能直接在浏览器中打开：\n\n![](https://pic.yupi.icu/1/1713416598726-d857bbd7-84b4-4148-9ad3-225412926af6.png)\n\n\n\n如果复制的是图片和文件，会展示占用的空间大小；复制的是文本，将展示字数等。\n\n![](https://pic.yupi.icu/1/1713416668587-36a5c786-870c-4525-9640-cd5c42088887.png)\n\n\n\n### 欢迎免费使用\n\nOK 就介绍到这里，欢迎大家使用剪切助手：[https://jianqiezhushou.com](",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 57,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-23 16:55:07",
        "updateTime": "2024-04-28 08:46:42",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3085,
          "coin": 170,
          "followeeNum": 1488,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-21 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-04-28 01:02:16"
        },
        "tags": [
          "文章",
          "产品"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1782602505440485378",
        "title": "状态机概念以及使用",
        "description": "状态机概念以及使用",
        "content": "### 状态机的组成\n\n状态机是一种抽象的数学模型，描述了对象或系统在特定时间点可能处于的各种状态以及状态之间的转换规则。它由一组状态、事件、转移和动作组成，用于模拟对象在不同条件下的行为和状态变化。\n\n<img src=\"https://markdown-piggo.oss-cn-guangzhou.aliyuncs.com/img/image-20240423094124100.png\" alt=\"image-20240423094124100\" style=\"zoom: 33%;\" />\n\n状态机包括以下基本组成部分：\n\n- 状态（State）：表示对象或系统当前的状态，例如开、关、就绪等。\n- 事件（Event）：触发状态转换的动作或条件，例如按钮点击、消息到达等。\n- 转移（Transition）：定义了从一个状态到另一个状态的转换规则，通常与特定事件相关联。\n- 动作（Action）：在状态转换过程中执行的操作或行为，例如更新状态、记录日志等。\n\n状态机，也就是 State Machine ，不是指一台实际机器，而是指一个数学模型。说白了，一般就是指一张状态转换图。例如，根据自动门的运行规则，我们可以抽象出下面这么一个图。\n\n![image-20240423095540911](https://markdown-piggo.oss-cn-guangzhou.aliyuncs.com/img/image-20240423095540911.png)\n\n### 简单实现\n\n在计算机中，状态机通常用编程语言来实现。在 C、C++、Java、Python 等编程语言中，可以通过使用 switch-case 语句、if-else 语句、状态转移表等来实现状态机。在下面还有更加优雅的方式，使用 Spring 状态机 来实现。\n\n\n\n#### if-else 实现状态机\n\n在上面的示例中，我们使用 `if-else` 结构根据当前活动来控制音乐的播放状态，并执行相应的行为。代码如下：\n\n```java\npublic class BasketballMusicStateMachineUsingIfElse {\n    private boolean isPlayingMusic;\n\n    public BasketballMusicStateMachineUsingIfElse() {\n        this.isPlayingMusic = false; // 初始状态为音乐未播放\n    }\n\n    public void playMusic() {\n        if (!isPlayingMusic) {\n            System.out.println(\"Music starts playing...\");\n            isPlayingMusic = true;\n        }\n    }\n\n    public void stopMusic() {\n        if (isPlayingMusic) {\n            System.out.println(\"Music stops playing...\");\n            isPlayingMusic = false;\n        }\n    }\n\n    public void performActivity(String activity) {\n        if (\"basketball\".equals(activity)) {\n            System.out.println(\"Music~\");\n            playMusic(); // 打篮球时播放音乐\n        } else if (\"sing_rap\".equals(activity)) {\n            System.out.println(\"哎哟你干嘛!\");\n            stopMusic(); // 唱跳Rap时停止音乐\n        } else {\n            System.out.println(\"Invalid activity!\");\n        }\n    }\n\n    public static void main(String[] args) {\n        BasketballMusicStateMachineUsingIfElse stateMachine = new BasketballMusicStateMachineUsingIfElse();\n\n        // 测试状态机\n        stateMachine.performActivity(\"basketball\"); // 打篮球，音乐开始播放\n        stateMachine.performActivity(\"sing_rap\"); // 唱跳Rap，音乐停止播放\n        stateMachine.performActivity(\"basketball\"); // 再次打篮球，音乐重新开始播放\n    }\n}\n```\n\n\n\n#### switch-case 实现状态机\n\n在这个示例中，我们使用 `switch-case` 结构根据不同的活动来控制音乐的播放状态，并执行相应的行为。代码如下：\n\n```java\npublic class BasketballMusicStateMachineUsingSwitchCase {\n    private boolean isPlayingMusic;\n\n    public BasketballMusicStateMachineUsingSwitchCase() {\n        this.isPlayingMusic = false; // 初始状态为音乐未播放\n    }\n\n    public void playMusic() {\n        if (!isPlayingMusic) {\n            System.out.println(\"Music starts playing...\");\n            isPlayingMusic = true;\n        }\n    }\n\n    public void stopMusic() {\n        if (isPlayingMusic) {\n            System.out.println(\"Music stops playing...\");\n            isPlayingMusic = false;\n        }\n    }\n\n    public void performActivity(String activity) {\n        switch (activity) {\n            case \"basketball\":\n                System.out.println(\"Music ~\");\n                playMusic(); // 打篮球时播放音乐\n                break;\n            case \"sing_rap\":\n                System.out.println(\"哎哟 你干嘛 ~\");\n                stopMusic(); // 唱跳Rap时停止音乐\n                break;\n            default:\n                System.out.println(\"Invalid activity!\");\n        }\n    }\n\n    public static void main(String[] args) {\n        BasketballMusicStateMachineUsingSwitchCase stateMachine = new BasketballMusicStateMachineUsingSwitchCase();\n\n        // 测试状态机\n        stateMachine.performActivity(\"basketball\"); // 打篮球，音乐开始播放\n        stateMachine.performActivity(\"sing_rap\"); // 唱跳Rap，音乐停止播放\n        stateMachine.performActivity(\"basketball\"); // 再次打篮球，音乐重新开始播放\n    }\n}\n\n```\n\n是不是感觉状态机其实经常在我们的日常使用中捏~，接下来带大家使用更优雅的状态机 Spring 状态机。\n\n<img src=\"https://markdown-piggo.oss-cn-guangzhou.aliyuncs.com/img/image-20240423100302874.png\" alt=\"image-20240423100302874\" style=\"zoom:50%;\" />\n\n\n\n#### 使用 Spring 状态机\n\n1）引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.statemachine</groupId>\n    <artifactId>spring-statemachine-core</artifactId>\n    <version>2.0.1.RELEASE</version>\n</dependency>\n```\n\n2）定义状态和事件的枚举\n\n代码如下：\n\n```java\npublic enum States {\n    IDLE,       // 空闲状态\n    PLAYING_BB, // 打篮球状态\n    SINGING     // 唱跳Rap状态\n}\npublic enum Event {\n    START_BB_MUSIC, // 开始播放篮球音乐事件\n    STOP_BB_MUSIC   // 停止篮球音乐事件\n}\n```\n\n3）配置状态机\n\n代码如下：\n\n```java\n@Configuration\n@EnableStateMachine\npublic class BasketballMusicStateMachineConfig extends EnumStateMachineConfigurerAdapter<States, Event> {\n\n    @Autowired\n    private BasketballMusicStateMachineEventListener eventListener;\n\n    @Override\n    public void configure(StateMachineConfigurationConfigurer<States, Event> config) throws Exception {\n        config\n            .withConfiguration()\n            .autoStartup(true)\n            .listener(eventListener); // 设置状态机事件监听器\n    }\n\n    @Override\n    public void configure(StateMachineStateConfigurer<States, Event> states) throws Exception {\n        states\n            .withStates()\n            .initial(States.IDLE)\n            .states(EnumSet.allOf(States.class));\n    }\n\n    @Override\n    public void configure(StateMachineTransitionConfigurer<States, Event> transitions) throws Exception {\n        transitions\n            .withExternal()\n            .source(States.IDLE).target(States.PLAYING_BB).event(Event.START_BB_MUSIC)\n            .and()\n            .withExternal()\n            .source(States.PLAYING_BB).target(States.SINGING).event(Event.STOP_BB_MUSIC)\n            .and()\n            .withExternal()\n            .source(States.SINGING).target(States.PLAYING_BB).event(Event.START_BB_MUSIC);\n    }\n}\n```\n\n4）定义状态机事件监听器\n\n代码如下：\n\n```java\n@Component\npublic class BasketballMusicStateMachineEventListener extends StateMachineListenerAdapter<States, Event> {\n\n    @Override\n    public void stateChanged(State<States, Event> from, State<States, Event> to) {\n        if (from.getId() == States.IDLE && to.getId() == States.PLAYING_BB) {\n            System.out.println(\"开始打篮球，music 起\");\n        } else if (from.getId() == States.PLAYING_BB && to.getId() == States.SINGING) {\n            System.out.println(\"唱跳，你干嘛\");\n        } else if (from.getId() == States.SINGING && to.getId() == States.PLAYING_BB) {\n            System.out.println(\"继续打篮球，music 继续\");\n        }\n    }\n}\n```\n\n5）编写单元测试\n\n```java\n@SpringBootTest\nclass ChatApplicationTests {\n    @Resource\n    private StateMachine<States, Event> stateMachine;\n\n    @Test\n    void contextLoads() {\n        //开始打球，music 起\n        stateMachine.sendEvent(Event.START_BB_MUSIC);\n\t\t//开始唱跳，你干嘛\n        stateMachine.sendEvent(Event.STOP_BB_MUSIC);\n\t\t//继续打球，music 继续\n        stateMachine.sendEvent(Event.START_BB_MUSIC);\n\n    }\n}\n```\n\n\n\n效果如下：\n\n![image-20240423103523546](https://markdown-piggo.oss-cn-guangzhou.aliyuncs.com/img/image-20240423103523546.png)\n\n\n\n在上面的示例中，我们定义了一个状态机，用于控制在打篮球时音乐的播放和唱跳 Rap 的行为。通过触发事件来执行状态转移，并通过事件监听器监听状态变化并执行相应的操作。\n\n![image-20240423103604502](https://markdown-piggo.oss-cn-guangzhou.aliyuncs.com/img/image-20240423103604502.png)",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 18,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1612254411675926529",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-23 10:48:51",
        "updateTime": "2024-04-28 01:00:37",
        "user": {
          "id": "1612254411675926529",
          "planetCode": "12852",
          "userName": "聪ζ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 3,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-08-21 21:17:54",
          "lastLoginTime": null,
          "createTime": "2023-01-09 09:06:20",
          "updateTime": "2024-04-23 21:43:28"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1782596110213210113",
        "title": "偷偷分享下我们公司的研发规范~",
        "description": null,
        "content": "大家好，我是程序员鱼皮。前几天我分享了自己 [创业一周年的复盘总结](https://mp.weixin.qq.com/s/PLlTO3xq6eheDJKUu9j4IA) ，其中提到了一点：随着团队的扩大，我们会更注重研发规范和技术沉淀。\n\n有程序员朋友就问了：啥是研发规范？\n\n还有朋友表示：鱼皮别拿咱当外人，把你们公司的研发规范发来看看？\n\n![](https://pic.yupi.icu/1/image-20240419140208921.png)\n\n可以，必须安排！\n\n这篇文章就给大家简单分享下我们公司的研发规范，不过在开始前必须要明确 2 点：\n\n1. 每个团队都应该根据情况定制自己的研发规范，别人的规范仅供参考，未必最适合你们团队。\n2. 篇幅有限，本文仅分享一些我认为很重要的规范，并且移除了我们自己的敏感信息。\n\n\n\n## 一、项目整体研发流程\n\n1）团队共同确认目标和规划\n\n开会讨论，产出目标和规划文档\n\n2）产品调研和需求分析\n\n产出调研报告和需求分析文档\n\n3）需求评审\n\n开需求评审会，明确要做的需求和工作，评估工作量并明确工作时间节点。\n\n4）方案设计\n\n产出方案设计文档，比如数据库表设计、页面设计、接口设计等。\n\n5）研发\n\n包括各自开发、单元测试、前后端联调等\n\n6）测试和验收\n\n包括研发自测、产品验收、组内验收等\n\n7）代码提交\n\n提交可上线的代码，需要由负责人审查，通过后可合并\n\n8）部署上线\n\n将代码发布到服务器上，组内进行上线通知并更新上线文档，上线后需要自行验证\n\n9）产品迭代\n\n持续收集用户对新功能的反馈、并进行数据分析，从而验证改动效果，便于下一轮的更新迭代。\n\n\n\n## 二、开发规范\n\n### 开发前注意事项\n\n1）确保自己充分理解了业务和需求，需要先进行整体的方案设计；尤其是对于重要需求和核心业务，必须先跟组内同学核对方案并通过后，才能下手开发，避免重复工作。\n\n2）先熟悉项目再开发，建议阅读项目文档、项目代码、接口文档、前端组件文档等。\n\n3）慎重引入新的依赖或类库、或者升级版本，重大依赖变更需要和组内其他成员确认。\n\n4）熟悉团队已实现的功能和代码，尽量复用，避免重复开发。\n\n5）熟悉团队内部的研发规范，并在 IDE 中进行相应的配置，比如前端配置 ESLint、Prettier 等代码规范插件。\n\n\n\n### 开发中注意事项\n\n1）开发新功能时，确保从项目仓库拉取 **最新主分支** 的代码。\n\n2）每个功能都要新建自己的分支进行开发，**千万不要直接修改主分支的代码**！注意分支名称要使用英文、足够语义化，不要和其他人的混淆。\n\n3）开发时，尽量复用现有的功能、模块、类、方法、对象代码。有现成的代码，就不要再重复编写。如无法复用，可以适当通过注释说明。\n\n4）开发时，遵循团队内部的研发规范，尽量参考现有项目代码的写法，尤其是不要使用和原项目不一致的格式、命名、写法，避免特立独行。\n\n5）开发过程中，有任何不明确的地方，不要凭空猜测，及时去联系项目的其他成员或负责人确认。\n\n6）开发过程中，每隔一段时间（比如 1 - 3 天）可以使用 `git pull` 同步一下最新的主分支代码，防止合并代码冲突。\n\n7）开发过程中，注意整体时间进度的把控，先完成再完美，有风险时及时反馈。\n\n8）开发时，需要格外注意对异常情况的捕获和处理。\n\n9）每个分支尽量保证纯净，尽量减少每次开发和提交时改动的代码量。建议每次开分支只改一个功能、Bug 或模块，不要把多个不相关的功能写在一起，并且非必要不修改。\n\n10）完成部分功能开发后，一定要自测！自测时，可以 Mock 假数据。**注意一定不要在线上测试、一定不要影响线上数据！**\n\n\n\n## 三、代码提交规范\n\n1）只有通过测试和产品验收的代码，才能够发起合并到主分支的 PR 请求。在这之前可以提交到自己的分支。\n\n2）发起合并到主分支的 PR 前，**一定要完整阅读 3 遍自己的代码**，避免不规范的写法和无意义的改动。\n\n3）每次合并尽量只专注于一个功能或改动，避免多个功能耦合在一起合并，提高审查效率并降低改动风险。\n\n4）每次提交时，需要在 commit 信息中提供代码改动说明，还可以通过关联需求文档、测试用例、方案文档、效果截图等方式进行补充说明。\n\ncommit 信息可参考[《约定式提交》文档](https://www.conventionalcommits.org/zh-hans/v1.0.0/)，但不做强制要求。\n\n5）除非特殊情况，否则所有的代码必须经过至少一位项目负责人 Code Review 审核通过后，才能合并；并且只有合并到主分支的代码才允许发布上线。\n\n\n\n## 上线规范\n\n### 上线前注意事项\n\n1）上线前，除了严格验证功能特性能否正常运行、并符合需求外，还要格外关注程序的：\n\n- 健壮性。比如给用户友好的错误提示、输入校验。\n- 安全性。防止越权操作、输入校验。\n- 稳定性。尽量保证调用 100% 成功，如果有几率失败，要考虑重试或容错策略。\n\n2）除非特殊情况，只有经过产品验证的功能、通过代码审核的主分支代码才允许发布上线。\n\n3）除非特殊情况，尽量在工作日上线（建议周二 ~ 周四），保证上线后出了问题时能够及时修复。\n\n\n\n### 上线后注意事项\n\n1）上线后，一定要再次进行完整流程的测试，尤其要重点关注权限相关的功能测试。\n\n2）上线后，一定要在群内及时同步上线信息，周知相关的成员，如果遇到问题第一时间反馈。\n\n3）首次上线后，需要即时配置监控告警。\n\n4）上线验证通过、并经过内部群成员确认后，可以在外部用户群发布版本更新公告。\n\n5）上线后，即时更新项目的更新记录文档。\n\n6）注意，上线不是终点。上线后的一段时间（至少一周内），一定要持续观察自己负责的功能是否正常运行、持续接受用户反馈、通过数据分析来观察新功能的效果，期间有任何问题都需要即时修复处理，并且准备好下一期的改进迭代。\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 47,
        "thumbNum": 1,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-23 10:23:26",
        "updateTime": "2024-04-28 05:22:09",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3085,
          "coin": 170,
          "followeeNum": 1488,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2286-11-21 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-04-28 01:02:16"
        },
        "tags": [
          "文章",
          "技术"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1781900732505546753",
        "title": "收获编程导航球友300多条点赞的豪华版API接口开放平台来了！！ 附上线部署流程及github action 自动化部署",
        "description": "",
        "content": "星球文章地址：https://t.zsxq.com/1934T92nb\n\n## 网站导航 \uD83E\uDDED\n- [Qi-API 接口开放平台 \uD83D\uDD17](https://api.qimuu.icu/nJaixWyb)  ：https://api.qimuu.icu/nJaixWyb\n- [Qi-API 后端 \uD83C\uDFD8️ ](https://github.com/qimu666/qi-api)：https://github.com/qimu666/qi-api\n- [Qi-API 前端 \uD83C\uDFD8️](https://github.com/qimu666/qi-api-frontend) ：https://github.com/qimu666/qi-api-frontend\n- [Qi-API-SDK\uD83D\uDEE0](https://github.com/qimu666/qi-api-sdk): https://github.com/qimu666/qi-api-sdk\n- [Qi-API-DOC 开发者文档 \uD83D\uDCD6](https://doc.qimuu.icu/) : https://doc.qimuu.icu/\n- [Qi-API-DOC 开发者文档源码 \uD83D\uDCD6](https://github.com/qimu666/qi-api-doc) : https://github.com/qimu666/qi-api-doc\n- [Qi-API-SDK-demo ✔️](https://github.com/qimu666/qi-api-sdk-demo) : https://github.com/qimu666/qi-api-sdk-demo\n- 部署流程见飞书文档：‍‌⁣⁣https://pqx6sigueez.feishu.cn/wiki/ZsDUwytgDibJ41kHBuwc1neVnUe\n\n- [Gitee同步地址](https://gitee.com/qimu6)：https://gitee.com/qimu6\n## 项目介绍 \uD83D\uDE4B\n\uD83D\uDE00 作为用户您可以通过注册登录账户，获取接口调用权限，并根据自己的需求浏览和选择适合的接口。您可以在线进行接口调试，快速验证接口的功能和效果。\n\n\uD83D\uDCBB 作为开发者 我们提供了客户端SDK， 通过开发者凭证即可将轻松集成接口到您的项目中，实现更高效的开发和调用。\n\n\uD83E\uDD1D 您可以将自己的接口接入到Qi-API 接口开放平台平台上，并发布给其他用户使用。 您可以管理和各个接口，以便更好地分析和优化接口性能。\n\n\uD83D\uDC4C 我们还提供了开发者在线文档和技术支持，帮助您快速接入和发布接口。\n\n\uD83C\uDFC1 无论您是用户还是开发者，Qi-API 接口开放平台都致力于提供稳定、安全、高效的接口调用服务，帮助您实现更快速、便捷的开发和调用体验。\n\n部署流程见文档：‍‌⁣⁣https://pqx6sigueez.feishu.cn/wiki/ZsDUwytgDibJ41kHBuwc1neVnUe\n## 项目整体流程图 \uD83D\uDDFA️：\n![api.png](https://pic.code-nav.cn/post_picture/1611320795533934593/ghS0OMlk-api.png)\n\n## 扩展功能点 \uD83D\uDCCB：\n\n- ✅ SDK开发 ：为了让用户更放便的掉用接口，我把sdk迭代了3个版本，参考各大接口平台SDK、运用多种设计模式，最终，完成了这项简单又复杂的版本。现在引入依赖坐标，几行代码就能轻松调用接口。\n- ✅ 开发者API在线文档 ：使用vuepress搭建了接口在线文档、提示用户体验，用户可以在这里找到更加详细的接口描述、示例代码、错误码参考等，并且提供调用Qi-API-SDK-Demo示例\n- ✅ EasyWeb：提供快速构建Web项目的sdk,只需导入依赖即可使用全局异常处理器、通用返回、接口文档、并且可以自定义自己的错误规范。\n- ✅ 提供多种好玩的接口：随机土味情话、每日星座运势、随机毒鸡汤、获取天气信息、随机壁纸等接口。\n- ✅ 微信支付宝支付功能 ：网站接入支付功能可正常收款，用户可以充值坤(即积分)，坤币用来调用接口。\n- ✅ 接口管理 ：管理员可以发布、审核、下线接口，未发布的接口普通用户接口广场获取不到，管理员可以动态设置请求参数、响应参数、请求参数中参数设置为必选项时，用户请求会校验用户有没有填该选项，并且配置请求参数、响应参数，前端动态生成请求参数、响应参数的描述列表。并生成json代码的返回示例。\n- ✅ 在线调试 ：无需编写代码，即可在线发起请求调试接口，用户可以动态添加请求参数来在线调用接口，余额是不能调用的哦\n- ✅ 邀请好友注册得坤币：好友通过你的链接注册账号双方都可以获得坤币奖励。体验链接：\n通过链接注册，即可获得100坤币\uD83D\uDCB0奖励，Qi-API 接口开放平台为您提供稳定、安全、高效的接口调用服务！https://api.qimuu.icu/nJaixWyb\n- ✅ 每日签到 除了邀请好友注册和充值坤币外，每日签到也可以获得\"不菲\"的坤币奖励\n- ✅ 支付成功邮箱通知 : 用户支付成功后通过邮件来反馈支付状态，但是需要先绑定邮箱账号。\n- ✅ 邮箱验证码登录注册：为了提示用户体检，用户可以选择注册平台账号或者使用邮箱账号注册平台。平台账号绑定邮箱后可以使用邮箱验证码登录平台\n- ✅ 校验请求参数：必填项请求参数检验，通过校验请求参数可以减少用户积分无意义的消耗。\n- ✅ 接口大厅：用户可以在这里获取更多好玩的接口\n- ✅ 绑定、换绑邮箱、解绑邮箱，用户绑定邮箱后可以通过邮箱验证码来登录网站，也支持用户更换新的邮箱。\n- ✅ 订单管理：用户可以管理订单、支付已经创建完成的订单，取消订单或者删除订单记录\n- ✅ 切换主题 ：为了提示网站的趣味，增加了深色和暗色主题切换\n- ✅ 商品管理 ：管理员可以上架或下架商品，或者设置商品的规格，比如设置活动商品，用户只能购买一次\n- ✅ 用户管理 ：管理员除了管理用户信息外，还可以对违规的用户进行封号，改正后联系管理员解封。\n- ...... 更多功能请前往Qi-API 接口开放平台查看 https://api.qimuu.icu/nJaixWyb\n\n\n## 功能介绍 \uD83D\uDCCB\n\n`坤币`即积分，用于平台接口调用。\n\n|                          **功能**                           | 游客 | **普通用户** | **管理员** |\n| ----------------------------------------------------- |--------------|-----|-----|\n|        **[开发者API在线文档](http://doc.qimuu.icu)**        | ✅ | ✅ |     ✅      |\n|                 接口大厅搜索接口、浏览接口                  | ✅ | ✅ | ✅ |\n|                     邮箱验证码登录注册                      | ✅ | ✅ | ✅ |\n|    [**Qi-API-SDK**](https://github.com/qimu666/qi-api-sdk)使用 | ❌ | ✅ |     ✅      |\n|                     邀请好友注册得坤币                      | ❌ | ✅ |     ✅      |\n|                       微信支付宝付款                        | ❌ | ✅ | ✅ |\n|                        在线调试接口                         | ❌ | ✅ | ✅ |\n|                       每日签到得坤币                        | ❌ | ✅ | ✅ |\n|                          钱包充值                           | ❌ | ✅ | ✅ |\n|                     支付成功邮箱通知(需要绑定邮箱)                     | ❌ | ✅ | ✅ |\n|                          更新头像                           | ❌ | ✅ | ✅ |\n|                    绑定、换绑、解绑邮箱                     | ❌ | ✅ | ✅ |\n|                          取消订单、删除订单                          | ❌ | ✅ | ✅ |\n|                    商品管理、上线、下架                     | ❌ | ❌ |✅|\n|                    用户管理、封号解封等                     | ❌ | ❌ | ✅ |\n|                接口管理、接口发布审核、下架                 | ❌ | ❌ | ✅ |\n|                            退款                             | ❌ | ❌| ✅ |\n\n## 项目流程 \uD83D\uDDFA️\n\n![QiAPI 接口开放平台](https://img.qimuu.icu/typory/QiAPI%2520%25E6%258E%25A5%25E5%258F%25A3%25E5%25BC%2580%25E6%2594%25BE%25E5%25B9%25B3%25E5%258F%25B0.png)\n\n## 快速启动 \uD83D\uDE80\n\n### 前端\n\n环境要求：Node.js >= 16\n\n安装依赖：\n\n```bash\nyarn or npm install\n```\n\n启动：\n\n```bash\nyarn run dev or npm run start:dev\n```\n\n部署：\n\n```bash\nyarn build or npm run build\n```\n\n### 后端\n\n执行sql目录下ddl.sql\n\n## 项目选型 \uD83C\uDFAF\n\n### **后端**\n\n- Spring Boot 2.7.0\n- Spring MVC\n- MySQL 数据库\n- 腾讯云COS存储\n- Dubbo 分布式（RPC、Nacos）\n- Spring Cloud Gateway 微服务网关\n- API 签名认证（Http 调用）\n- IJPay-AliPay  支付宝支付\n- WeiXin-Java-Pay  微信支付\n- Swagger + Knife4j 接口文档\n- Spring Boot Starter（SDK 开发）\n- Jakarta.Mail 邮箱通知、验证码\n- Spring Session Redis 分布式登录\n- Apache Commons Lang3 工具类\n- MyBatis-Plus 及 MyBatis X 自动生成\n- Hutool、Apache Common Utils、Gson 等工具库\n\n### 前端\n\n- React 18\n\n- Ant Design Pro 5.x 脚手架\n\n- Ant Design & Procomponents 组件库\n\n- Umi 4 前端框架\n\n- OpenAPI 前端代码生成\n\n\n## 功能展示 ✨\n\n### 首页\n\n![index.png](https://pic.code-nav.cn/post_picture/1611320795533934593/aarAFFs2-index.png)\n\n### 接口广场\n\n![interfaceSquare.png](https://pic.code-nav.cn/post_picture/1611320795533934593/hvDq712E-interfaceSquare.png)\n\n### 开发者在线文档\n\n![api.png](https://pic.code-nav.cn/post_picture/1611320795533934593/z2NSNfqo-api.png)\n\n![api2.png](https://pic.code-nav.cn/post_picture/1611320795533934593/Zb7ReIWn-api2.png)\n\n### 接口描述\n\n#### **在线API**\n\n![interfaceinfo-api.png](https://pic.code-nav.cn/post_picture/1611320795533934593/wkJXsYzU-interfaceinfo-api.png)\n\n#### 在线调试工具\n\n![interfaceinfo-tools.png](https://pic.code-nav.cn/post_picture/1611320795533934593/N0mxKOp7-interfaceinfo-tools.png)\n#### **错误码参考**\n\n![interfaceinfo-errorcode.png](https://pic.code-nav.cn/post_picture/1611320795533934593/AcIZOINg-interfaceinfo-errorcode.png)\n\n#### **接口调用代码示例**\n\n![interfaceinfo-sampleCode.png](https://pic.code-nav.cn/post_picture/1611320795533934593/tIxsOyn3-interfaceinfo-sampleCode.png)\n### 管理页\n\n#### 用户管理\n\n\n![admin-userManagement.png](https://pic.code-nav.cn/post_picture/1611320795533934593/VbFAvqVR-admin-userManagement.png)\n\n#### 商品管理\n\n![admin-productManagement.png](https://pic.code-nav.cn/post_picture/1611320795533934593/nu2xB2gv-admin-productManagement.png)\n\n#### 接口管理\n\n![admin-interfaceManagement.png](https://pic.code-nav.cn/post_picture/1611320795533934593/mUUvE3ii-admin-interfaceManagement.png)\n\n#### 动态更新请求响应参数\n\n![dynamicRequestParameters.png](https://pic.code-nav.cn/post_picture/1611320795533934593/mmiDKmi1-dynamicRequestParameters.png)\n\n\n### 积分商城\n\n\n![pointPurchase.png](https://pic.code-nav.cn/post_picture/1611320795533934593/v5tuG4au-pointPurchase.png)\n\n### 订单支付\n\n![pay.png](https://pic.code-nav.cn/post_picture/1611320795533934593/Sg2YXtjB-pay.png)\n### 个人信息\n\n#### 信息展示\n\n![userinfo.png](https://pic.code-nav.cn/post_picture/1611320795533934593/S4xv5YUQ-userinfo.png)\n\n#### 每日签到\n\n##### 签到成功\n\n![successfullySignedIn.png](https://pic.code-nav.cn/post_picture/1611320795533934593/tpvG7jca-successfullySignedIn.png)\n\n##### 签到失败\n\n![errorfullySignedIn.png](https://pic.code-nav.cn/post_picture/1611320795533934593/d6He9Q6T-errorfullySignedIn.png)\n\n### 好友邀请\n\n#### **发送邀请**\n\n![Invitefriends.png](https://pic.code-nav.cn/post_picture/1611320795533934593/xWqhjrQB-Invitefriends.png)\n#### **接收邀请**\n\n![registerThroughInvitationCode.png](https://pic.code-nav.cn/post_picture/1611320795533934593/3YKUh8H7-registerThroughInvitationCode.png)\n### 登录/注册\n\n![login.png](https://pic.code-nav.cn/post_picture/1611320795533934593/ftMqAxjb-login.png)\n\n![register.png](https://pic.code-nav.cn/post_picture/1611320795533934593/AsY5fJCU-register.png)\n### 订单管理\n\n- **我的订单**\n![orderinfo.png](https://pic.code-nav.cn/post_picture/1611320795533934593/HzfSvomX-orderinfo.png)\n- **详细订单**\n\n![orderDetails.png](https://pic.code-nav.cn/post_picture/1611320795533934593/OCCUMZjN-orderDetails.png)\n### 主题切换\n\n#### 深色主题\n\n![darkTheme.png](https://pic.code-nav.cn/post_picture/1611320795533934593/1AFJEsTc-darkTheme.png)\n\n#### 浅色主题\n\n![index.png](https://pic.code-nav.cn/post_picture/1611320795533934593/3X3hn91v-index.png)",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1611320795533934593/xGHjyDlo-interfaceSquare.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 61,
        "thumbNum": 3,
        "favourNum": 5,
        "commentNum": 2,
        "priority": 0,
        "userId": "1611320795533934593",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-21 12:20:15",
        "updateTime": "2024-04-28 05:25:21",
        "user": {
          "id": "1611320795533934593",
          "planetCode": "15730",
          "userName": "柒木",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/LXWUAxyUBKG2Iq5ibyoqiaicAVMGbq3BLaZySsm4pE1ZpL3bUicM5mPiccbAJKwETGpMUicJxr084jibz0arXzgVUfaRQ/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [
            "GitHub",
            "Java"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "实习中",
          "company": null,
          "job": "后端",
          "workYear": 1,
          "direction": "后端",
          "goal": "考公",
          "github": "https://github.com/qimu666",
          "blog": "https://www.cnblogs.com/qimu666/",
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-11-30 16:20:20",
          "lastLoginTime": null,
          "createTime": "2023-01-06 19:16:29",
          "updateTime": "2024-04-28 01:03:09"
        },
        "tags": [
          "文章",
          "Java",
          "API接口"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1781657465557901314",
        "title": "Gradle 进阶学习之 Dependencies 【依赖】",
        "description": "在Gradle中，依赖管理是一个非常重要的部分，它允许你指定项目所需的各种库和模块。你的案例中提到了三种常见的依赖类型：项目依赖、本地JAR依赖和远程仓库的直接依赖。下面我将分别解释这三种依赖类型，并",
        "content": "# 1、依赖的方式\n\n> Gradle 中的依赖分别为直接依赖，项目依赖，本地 jar 依赖。\n\n在Gradle中，依赖管理是一个非常重要的部分，它允许你指定项目所需的各种库和模块。你的案例中提到了三种常见的依赖类型：项目依赖、本地JAR依赖和远程仓库的直接依赖。下面我将分别解释这三种依赖类型，并提供相应的配置方法。\n\n### 1.1 直接依赖（远程仓库依赖）\n\n直接依赖指的是从远程仓库（如Maven Central）中获取的依赖。在Gradle中，你可以直接通过坐标来声明这些依赖，如下所示：\n\n```groovy\ndependencies {\n    // 直接依赖的简写形式\n    implementation 'cn.hutool:hutool-all:5.8.27'\n\n    // 直接依赖的完整形式\n    iimplementation group: 'cn.hutool', name: 'hutool-all', version: '5.8.27'\n}\n```\n\n![image-20240420194013517](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420194013517.png)\n\n在Maven的`pom.xml`文件中，这相当于：\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>cn.hutool</groupId>\n        <artifactId>hutool-all</artifactId>\n        <version>5.8.27</version>\n\t</dependency>\n</dependencies>\n```\n\n在Gradle中，`implementation`是依赖配置之一，它相当于Maven中的`compile`作用域。\n\n### 1.2 项目依赖\n\n项目依赖是指在一个多模块项目中，一个模块依赖于另一个模块。在Gradle中，你可以使用`project`方法来声明这种依赖，如下所示：\n\n```groovy\ndependencies {\n    // 项目依赖\n    implementation project(':subject01')\n}\n```\n\n![image-20240420194227026](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420194227026.png)\n\n在`settings.gradle`文件中，你需要配置子模块的路径，以便Gradle能够识别它们：\n\n```groovy\nrootProject.name = 'root'\ninclude 'subject01' // 包含名为subject01的子模块\n```\n\n### 1.3 本地JAR依赖\n\n本地JAR依赖指的是直接引用项目目录中的JAR文件。在Gradle中，你可以使用`files`方法或`fileTree`方法来声明这些依赖：\n\n```groovy\ndependencies {\n    // 直接依赖特定的JAR文件\n    implementation files('libs/foo.jar', 'libs/bar.jar')\n\n    // 配置一个文件夹作为依赖项，自动包含该文件夹下的所有JAR文件\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n}\n```\n\n使用`fileTree`方法时，Gradle会自动包含指定目录下的所有JAR文件作为依赖。\n\n### 总结\n\n- **直接依赖**：从远程仓库获取的依赖，使用坐标声明。\n- **项目依赖**：在一个多模块项目中，一个模块对另一个模块的依赖。\n- **本地JAR依赖**：直接引用本地文件系统中的JAR文件。\n\n每种依赖类型都有其适用场景，你可以根据项目的具体需求选择合适的依赖管理方式。\n\n# 2、依赖的下载\n\n当执行 build 命令时，gradle 就会去配置的依赖仓库中下载对应的 Jar，并应用到项目中。\n\n# 3、依赖的类型\n\n类似于 Maven 的 scope 标签，gradle 也提供了依赖的类型,具体如下所示:\n\n| 配置选项             | 描述                                                         | 适用插件      |\n| -------------------- | ------------------------------------------------------------ | ------------- |\n| `compileOnly`        | 编译时需要但不打包的依赖。曾短暂称为`provided`。             | Java          |\n| `runtimeOnly`        | 运行时需要，编译时不需要的依赖，如数据库驱动。               | Java          |\n| `implementation`     | 编译和运行时都需要的依赖。                                   | Java          |\n| `testCompileOnly`    | 仅用于编译测试的依赖，运行时不需要。                         | Java          |\n| `testRuntimeOnly`    | 仅在测试运行时需要的依赖。                                   | Java          |\n| `testImplementation` | 针对测试代码的依赖，取代老版本中的`testCompile`。            | Java          |\n| `providedCompile`    | WAR插件专用，编译和测试需要，运行时由容器提供。              | WAR           |\n| `compile`            | 已在Gradle 7.0中移除，原表示编译时和打包时都需要的依赖。     | Java (已移除) |\n| `runtime`            | 已在Gradle 7.0中移除，原表示运行和测试时需要的依赖。         | Java (已移除) |\n| `api`                | 编译时和运行时都需要的依赖，并且可以被使用者传递性地导出。   | java-library  |\n| `compileOnlyApi`     | 仅在编译时需要的依赖，运行时不需要，可以被使用者传递性地导出。 | java-library  |\n\n请注意，`compile`和`runtime`配置选项在Gradle 7.0中已经被移除，推荐使用`implementation`和`runtimeOnly`作为替代。此外，`api`和`compileOnlyApi`是`java-library`插件提供的，用于更细粒度地控制模块间的依赖关系。\n\n> **官方文档参考**：\n>\n> https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin: 各个依赖范围的关系和说明\n>\n> https://docs.gradle.org/current/userguide/upgrading_version_6.html#sec:configuration_removal : 依赖范围升级和移除\n>\n> https://docs.gradle.org/current/userguide/java_library_plugin.html#java_library_plugin：API 和 implemention 区别\n>\n> https://docs.gradle.org/current/userguide/java_plugin.html#java_plugin: 执行 java 命令时都使用了哪些依赖范围的依赖。\n\n**提示**：java 插件提供的功能，java-library 插件都提供\n\n# 4、api 与 implementation 区别\n\n 以下是您提供的关于Gradle依赖配置选项`api`和`implementation`的比较表格，我对其进行了优化和整理：\n\n| 特性/场景    | `api`配置选项                                                | `implementation`配置选项                                     |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **编译时**   | - 依赖可以传递给模块的使用者。                               | - 依赖不会传递给模块的使用者。                               |\n|              | - 当底层依赖发生变化时，所有依赖了这些底层依赖的模块都需要重新编译，可能导致编译速度变慢。 | - 当底层依赖发生变化时，只有直接依赖了这些底层依赖的模块需要重新编译，编译速度相对较快。 |\n| **运行时**   | - 所有模块的类都会被加载。                                   | - 所有模块的类都会被加载。                                   |\n| **应用场景** | - 适用于多模块的项目，特别是当你想要避免重复依赖同一个模块时。 | - 在大多数情况下使用，尤其是当你不希望依赖传递给模块使用者时。 |\n\n`api`和`implementation`是Gradle中常用的两种依赖配置选项，它们在编译时和运行时的行为有所不同。`api`配置选项允许依赖传递，这在多模块的项目中非常有用，可以确保模块间的依赖关系一致性。而`implementation`配置选项则不会将依赖传递给使用者，这在大多数情况下是推荐使用的，因为它可以减少不必要的依赖传递，从而提高项目的构建效率。\n\n以下是对这两种依赖类型的详细解释，以及它们在编译时和运行时的不同影响：\n\n### 4.1 api 依赖\n\n- **编译时**：当一个库（如 libC）被声明为 `api` 依赖时，它的内容变化会导致所有直接和间接依赖它的项目（如 libA 和 projectX）都需要重新编译。这是因为 `api` 依赖的变更可能会影响所有使用该 API 的代码。\n\n- **运行时**：在运行时，所有通过 `api` 依赖的库（如 libC、libA）以及最终的应用程序（如 projectX）中的类都会被类加载器加载。\n\n- **适用场景**：`api` 适用于多模块项目中的依赖管理，特别是当你想避免重复依赖时。例如，如果 moduleA 依赖 moduleB，而 moduleB 又依赖 moduleC，同时 moduleA 也需要 moduleC 中的某些类或方法，你可以将 moduleC 作为 `api` 依赖添加到 moduleB 中。这样，moduleA 只需要依赖 moduleB，而 moduleC 的依赖会被传递。\n\n### 4.2 implementation 依赖\n\n- **编译时**：使用 `implementation` 依赖时，依赖的传递性会被限制。如果一个库（如 libD）被声明为 `implementation` 依赖，并且它的内容发生变化，只有直接依赖它的库（如 libB）需要重新编译。不依赖于 libD 的项目（如 libA 和 projectX）不需要重新编译，这可以加快编译速度。\n\n- **运行时**：尽管在编译时 `implementation` 依赖不会被传递，但在运行时，所有通过 `implementation` 依赖引入的库（如 libD、libB）以及最终的应用程序（如 projectX）中的类都会被加载。\n\n- **适用场景**：`implementation` 适用于那些不应该被其他模块或应用程序直接使用的库。它通常是内部实现细节，不是用来暴露公共 API 的。\n\n### 4.3 拓展 \n\napi 和 implementation 案例分析 :\n\n在多模块项目中，使用 `api` 和 `implementation` 可以有效地管理模块之间的依赖关系：\n\n- **使用 `api`**：当你希望一个模块的依赖成为另一个模块的公共 API 时，使用 `api`。这样，任何依赖于该模块的项目都能够访问到这些 API。\n\n- **使用 `implementation`**：当你希望隐藏一个模块的实现细节，只将必要的功能暴露给依赖它的模块时，使用 `implementation`。这有助于减少编译时的依赖传递，提高构建效率。\n\n总之，除非涉及到多模块依赖，为了避免重复依赖，咱们会使用api,其它情况我们优先选择implementation，拥有大量的 api依赖项会显著增加构建时间。\n\n# 5、依赖冲突及解决方案\n\n依赖冲突是指 \"在编译过程中, 如果存在某个依赖的多个版本, 构建系统应该选择哪个进行构建的问题\",如下所示:\n\n![image-20240420195402674](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420195402674.png)\n\nA、B、C 都是本地子项目 module，log4j 是远程依赖。\n\n**编译时：** B 用 1.4.2 版本的 log4j，C 用 2.2.4 版本的 log4j,B 和 C 之间没有冲突\n\n**打包时：** 只能有一个版本的代码最终打包进最终的A对应的 jar 或 war包，对于 Gradle 来说这里就有冲突了\n\n## 5.1 案例演示：\n\n我们在 build.gradle 引入依赖库\n\n![image-20240420195849916](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420195849916.png)\n\n修改 build.gradle\n\n![image-20240420195949082](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420195949082.png)\n\n如上所示：默认下，Gradle 会使用最新版本的 jar 包【考虑到新版本的 jar 包一般都是向下兼容的】，实际开发中，还\n\n是建议使用官方自带的这种解决方案。**当然除此之外，Gradle 也为我们提供了一系列的解决依赖冲突的方法**: **exclude** \n\n**移除一个依赖**，**不允许依赖传递**，**强制使用某个版本**。\n\n## 5.2 Exclude 排除某个依赖\n\n![image-20240420200138605](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420200138605.png)\n\n## 5.3 不允许依赖传递【一般不用】\n\n![image-20240420200227442](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420200227442.png)\n\n在添加依赖项时,如果设置 transitive 为 false,表示关闭依赖传递。即内部的所有依赖将不会添加到编译和运行时的类路径。\n\n## 5.4 强制使用某个版本【官方建议】\n\n![image-20240420200349538](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420200349538.png)\n\n## **拓展**\n\n在 Gradle 中，如果你想要避免依赖冲突并确保构建的可预测性，你可以配置构建过程在遇到依赖冲突时立即失败。这可以帮助你快速发现并解决版本不一致的问题。\n\n以下是如何配置 Gradle 在遇到依赖冲突时立即失败的示例：\n\n```groovy\nconfigurations.all {\n    resolutionStrategy.failOnVersionConflict()\n}\n```\n\n这段代码应该放在你的 `build.gradle` 文件中的项目配置部分。通过使用 `configurations.all` 方法，你可以为项目中所有的配置应用这个策略。`resolutionStrategy.failOnVersionConflict()` 会让 Gradle 在解析依赖时，如果遇到任何版本冲突，就会立即停止构建并报告错误。\n\n### 依赖冲突检查的好处\n\n- **及时发现问题**：构建失败提供了一个明确的信号，表明依赖之间存在不兼容的版本，这可以防止不兼容的依赖被无意中包含进构建中。\n\n- **简化调试**：立即失败可以简化调试过程，因为你不需要去猜测为什么构建成功但运行时却出现问题。\n\n- **避免运行时错误**：通过确保所有依赖都是兼容的，可以减少运行时由于依赖不匹配导致的意外错误。\n\n### 注意事项\n\n- 在团队协作中，这个策略可以帮助每个成员都意识到依赖版本的重要性。\n\n- 对于大型项目或有复杂依赖关系的情况，这个策略可能会导致频繁的构建失败，因此可能需要配合其他依赖管理策略使用。\n\n- 在实际操作中，可能需要结合项目的具体需求和依赖管理策略来决定是否使用这个选项。\n\n通过这种方式，你可以更好地控制项目的依赖，确保依赖的一致性和项目的稳定性。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1620630456775032833/7RAP7emg-gradle-logo.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 15,
        "thumbNum": 2,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1620630456775032833",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-20 20:13:36",
        "updateTime": "2024-04-24 16:26:08",
        "user": {
          "id": "1620630456775032833",
          "planetCode": "3790",
          "userName": "叫我阿杰好了",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1620630456775032833/VD8sEpIL-微信图片_20230523085336.jpg",
          "gender": 1,
          "userProfile": "目前技术社交账号，CSDN JAVA领域优秀创作者，阿里云专家博主。\n微信公众号：叫我阿杰好了",
          "userRole": "vip",
          "interests": [
            "资源",
            "Java",
            "GitHub",
            "面试题"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 3,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": "https://blog.csdn.net/weixin_53041251?spm=1000.2115.3001.5343",
          "score": 35,
          "coin": 20,
          "followeeNum": 1,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2025-03-12 23:57:24",
          "lastLoginTime": null,
          "createTime": "2023-02-01 11:49:45",
          "updateTime": "2024-04-20 17:19:53"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1781642497684955137",
        "title": "Gradle 进阶学习之 文件操作",
        "description": "Gradle 提供了强大的文件操作功能，包括创建和操作归档文件。通过定义任务和使用 Gradle 提供的插件，你可以轻松地将项目打包成所需的格式，并执行各种文件操作。",
        "content": "# Gradle 进阶学习之 文件操作\n\n# 1、本地文件\n\n在 Gradle 中，`Project.file(java.lang.Object)` 方法是一个非常有用的工具，它允许你以一种类型安全的方式引用文件。这个方法可以接收一个字符串路径，返回一个 `File` 对象，这个对象代表的是一个相对于当前项目目录（或者子项目目录）的文件或目录，或者是指定的绝对路径。\n\n### 1.1 使用 `Project.file` 方法\n\n以下是如何使用 `Project.file` 方法的示例：\n\n```groovy\n// 使用相对路径引用文件\nFile configFile = file('src/conf.xml')\nif (!configFile.exists()) {\n    configFile.createNewFile() // 创建文件\n}\n\n// 使用绝对路径引用文件\nconfigFile = file('C:\\\\code\\\\java\\\\gradle-01\\\\conf.xml')\nif (!configFile.exists()) {\n    println(configFile.createNewFile()) // 创建文件并打印结果\n}\n\n// 使用一个已有的 File 对象\nFile anotherConfigFile = new File('src/config.xml')\nprintln(anotherConfigFile.exists()) // 打印文件是否存在\n```\n\n![image-20240420173809382](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420173809382.png)\n\n### 1.2 相对路径和绝对路径\n\n- **相对路径**：当你使用相对路径时，Gradle 会将其解释为相对于当前项目的根目录（或子项目的根目录）的路径。例如，`'src/conf.xml'` 会指向当前项目根目录下的 `src` 子目录中的 `conf.xml` 文件。\n\n- **绝对路径**：绝对路径直接指向文件系统中的特定位置，不依赖于项目的目录结构。例如，`'D:\\\\conf.xml'` 指向 D 盘根目录下的 `conf.xml` 文件。\n\n### 1.3 `File` 对象的操作\n\n使用 `Project.file` 方法创建的 `File` 对象是 Java 中的 `java.io.File` 对象的一个实例。你可以使用它执行各种文件操作，比如检查文件是否存在、创建新文件、读取和写入文件内容等。\n\n### 1.4 注意事项\n\n- 当使用 `createNewFile()` 方法创建新文件时，如果文件已经存在，该方法将返回 `false`，并且不会覆盖现有文件。\n- 文件操作可能会因权限问题而失败，确保你的应用程序有足够的权限来执行这些操作。\n- 在实际的构建脚本中，通常建议使用 Gradle 提供的专门针对文件操作的任务类型，如 `Copy`、`Delete` 等，因为它们提供了更好的构建缓存支持和错误处理。\n\n### 1.5 总结\n\n`Project.file` 方法是 Gradle 中处理文件和目录的便捷方式，它结合了 Groovy 的简洁性和 Java `File` 类的功能，使得文件操作更加直观和易于管理。\n\n# 2、文件集合\n\n在 Gradle 中，`FileCollection` 接口代表一组文件，这个接口提供了多种方法来操作这组文件。你可以通过 `Project.files` 方法来创建一个 `FileCollection` 实例，该方法接受多个参数，包括字符串路径、`File` 对象数组或集合等。\n\n### 2.1 创建 `FileCollection`\n\n以下是如何使用 `Project.files` 方法创建 `FileCollection` 实例的示例：\n\n```groovy\ndef collection = files('src/test1.txt', new File('src/test2.txt'), ['src/test3.txt', 'src/test4.txt'])\n```\n\n在这个例子中，我们创建了一个包含多个不同类型文件引用的 `FileCollection` 对象。\n\n### 2.2 操作 `FileCollection`\n\n- **创建文件**：使用 `forEach` 遍历集合，并使用 `createNewFile()` 方法创建每个文件。\n\n```groovy\ncollection.forEach { File it ->\n    it.createNewFile()\n    println it.name // 输出文件名\n}\n```\n\n![image-20240420180132419](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420180132419.png)\n\n- **转换类型**：`FileCollection` 可以被转换为 Java 的 `Set` 或 `List` 类型。\n\n```groovy\nSet set1 = collection.files // 把文件集合转换为 java 中的 Set 类型\nSet set2 = collection as Set\nList list = collection as List // 把文件集合转换为 java 中的 List 类型\n```\n\n- **遍历 List**：可以遍历转换后的 `List` 并执行操作。\n\n```groovy\nfor (item in list) {\n    println item.name // 输出每个文件的名称\n}\n```\n\n![image-20240420180215227](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420180215227.png)\n\n- **集合操作**：可以使用 `+` 来添加一个文件集合，或者使用 `-` 来从一个集合中删除文件。\n\n```groovy\ndef union = collection + files('src/test5.txt') // 添加一个文件到集合\ndef minus = collection - files('src/test3.txt') // 从集合中删除一个文件\n```\n\n- **遍历新的集合**：可以遍历修改后的集合。\n\n```groovy\nunion.forEach { File it ->\n    println it.name // 输出添加到集合的每个文件的名称\n}\n```\n\n![image-20240420180650636](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420180650636.png)\n\n### 2.3 总结\n\nGradle 的 `FileCollection` 提供了一种灵活的方式来处理一组文件。你可以创建文件、遍历、转换集合、以及执行集合间的添加和删除操作。这些功能在编写构建脚本时非常有用，尤其是当你需要对多个文件执行相同操作时。通过使用 `FileCollection`，你可以编写更简洁、更可读的构建逻辑。\n\n# 3、文件树\n\n在 Gradle 中，文件树（`FileTree`）是一种特殊类型的 `FileCollection`，它表示具有层级结构的文件集合。文件树可以代表一个目录及其所有子目录中的文件，或者可以代表一个压缩文件（如 ZIP 文件）中的内容结构。\n\n文件树不仅具有文件集合的所有功能，还允许你访问文件的相对路径和处理具有层级结构的文件集合。以下是如何创建和使用文件树的示例：\n\n### 3.1 创建文件树\n\n```groovy\n// 第一种方式：使用路径创建文件树对象，并指定包含的文件\ndef tree = fileTree('src/main').include('**/*.java')\n\n// 第二种方式：通过闭包创建文件树\ntree = fileTree('src/main') {\n    include '**/*.java'\n}\n\n// 第三种方式：通过路径和闭包创建文件树，使用具名参数给 map 传值\ntree = fileTree(dir: 'src/main', include: '**/*.java')\n\n// 包含多个文件类型，并排除特定的目录或文件\ntree = fileTree(dir: 'src/main', includes: ['**/*.java', '**/*.xml', '**/*.txt'], exclude: '**/*test*/**')\n```\n\n### 3.2 使用文件树\n\n- **遍历文件树**：可以使用 `each` 方法遍历文件树中的所有文件。\n\n```groovy\ntree.each { File file ->\n    println file // 输出文件的完整路径\n    println file.name // 输出文件名\n}\n```\n\n![image-20240420181047704](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420181047704.png)\n\n- **过滤条件**：在创建文件树时，你可以使用 `include` 和 `exclude` 方法来指定过滤条件，以包含或排除特定的文件或目录。\n\n### 3.3 文件树的特点\n\n- **层级结构**：文件树保持了文件的目录结构，允许你访问文件相对于根目录的路径。\n- **过滤模式**：使用 Ant 风格的模式（如 `**/*.java`）来匹配文件和目录。\n- **动态性**：文件树的内容是动态生成的，每次访问时都会重新计算，这意味着它会反映文件系统中的当前状态。\n\n### 3.4 总结\n\n文件树是 Gradle 中处理具有层级结构文件集合的强大工具。通过使用文件树，你可以更方便地处理复杂的文件结构，执行批量文件操作，如复制、删除或分发文件。文件树的过滤功能也使得条件性文件操作变得简单，提高了构建脚本的灵活性和可维护性。\n\n# 4、文件拷贝\n\n在 Gradle 中，`Copy` 任务是用来拷贝文件和目录的。它非常灵活，允许你指定要拷贝的文件、目标目录，并且可以通过各种方式来修改拷贝行为，比如过滤、重命名文件等。\n\n### 4.1 使用 `Copy` 任务\n\n以下是如何定义和使用 `Copy` 任务的示例：\n\n```groovy\ntask copyTask(type: Copy) {\n    // 指定原文件或目录\n    from 'src/main/java'\n    // 指定目标目录\n    into 'src/main/resources'\n}\n```\n\n![image-20240420181755062](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420181755062.png)\n\n在这个例子中，`from` 方法用于指定要拷贝的源文件或目录，而 `into` 方法用于指定目标目录。\n\n### 4.2 拷贝时的过滤和重命名\n\n- **过滤条件**：可以使用 `include` 和 `exclude` 方法来添加过滤条件，以包含或排除特定的文件。\n\n```groovy\ntask copyTaskWithPatterns(type: Copy) {\n    from 'src/main/webapp'\n    into 'build/explodedWar'\n    // 只拷贝 HTML 和 JSP 文件\n    include '**/*.html'\n    include '**/*.jsp'\n    // 排除以 .html 结尾的文件\n    exclude { details -> details.file.name.endsWith('.html') }\n}\n```\n\n- **重命名**：可以使用 `rename` 方法来指定一个新的文件名，或者提供一个闭包来动态生成文件名。\n\n```groovy\ntask rename(type: Copy) {\n    from 'src/main/webapp'\n    into 'build/explodedWar'\n    // 使用闭包方式重命名文件，移除文件名中的 '-staging-' 文本\n    rename { String fileName ->\n        fileName.replace('-staging-', '')\n    }\n}\n```\n\n### 4.3 使用 `Project.copy` 方法\n\n除了使用 `Copy` 任务，Gradle 还提供了 `Project.copy` 方法，它允许你以更简洁的方式执行拷贝操作：\n\n```groovy\ntask copyMethod {\n    doLast {\n        copy {\n            // 相对路径或绝对路径\n            from 'src/main/webapp'\n            into 'build/explodedWar'\n            // 包括 HTML 和 JSP 文件\n            include '**/*.html'\n            include '**/*.jsp'\n        }\n    }\n}\n```\n\n另一种使用 `copy` 方法的方式是直接在项目级别进行：\n\n```groovy\ncopy {\n    from file('src/main/resources/ddd.txt') // 也可以使用 new File('src/main/resources/ddd.txt')\n    into buildDir.absolutePath\n}\n```\n\n这种方法可以直接在项目的任何地方调用，而不必定义为一个任务。\n\n### 4.4 执行拷贝操作\n\n要执行拷贝操作，你可以运行相应的任务，例如：\n\n```shell\ngradle copyTask\n```\n\n或者，如果你使用的是 `Project.copy` 方法，你可以通过调用注册的闭包来执行拷贝：\n\n```shell\ngradle copyMethod\n```\n\n### 4.5 总结\n\nGradle 提供了多种拷贝文件的方法，包括 `Copy` 任务、`Project.copy` 和 `project.copy`。每种方法都适用于不同的场景，允许你在构建过程中灵活地拷贝文件和目录。通过使用这些方法，你可以轻松地自动化资源的复制，提升构建脚本的效率。\n\n# 5、归档文件\n\n在 Gradle 中，处理归档文件是一项常见的任务，特别是当你需要将项目打包成 WAR、ZIP、TAR 等格式以便于发布或部署时。以下是如何使用 Gradle 来创建和操作这些归档文件的详细说明：\n\n### 5.1 创建 Zip 归档文件\n\n1. **应用插件**：首先，确保你的项目中应用了 Java 插件，这将提供创建 JAR 归档文件所需的类和功能。\n\n​\t![image-20240420182737310](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420182737310.png)\n\n2. **定义任务**：然后，定义一个名为 `myZip` 的任务，并指定其类型为 `Zip`。\n\n```groovy\ntask myZip(type: Zip) {\n    // 指定ZIP文件内容来源\n    from 'src/main/java'\n    // 指定ZIP文件解压后的内容存放目录\n    into 'build'\n    // 设置ZIP文件的基本名称\n    archiveBaseName = 'myZip'\n    // 设置ZIP文件的扩展名（这里虽然是多余的设置，因为已经默认是zip，但可以用来说明文件类型）\n    archiveExtension = 'zip'\n    // 设置ZIP文件的版本号\n    archiveVersion = '1.0'\n}\n```\n\n3. **执行任务**：通过运行 `gradle myZip` 命令来创建 Zip 文件。\n\n```shell\ngradle -q myZip\n```\n\n执行上述命令后，Gradle 会在指定的目录中创建一个名为 `myGame-1.0.zip` 的 Zip 文件。\n\n![image-20240420183841075](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420183841075.png)\n\n### 5.2 使用 `zipTree` 和 `tarTree`\n\nGradle 提供了 `zipTree` 和 `tarTree` 方法，它们可以创建一个 `FileTree` 对象，允许你访问 Zip 或 Tar 压缩包中的内容。这些方法非常适合当你需要将压缩包的内容作为文件集合的一部分来处理时使用。\n\n```groovy\ntask zipTree(type: Zip) {\n    // 指定打包的源文件，这里使用zipTree()函数来展开一个Zip文件作为打包的源\n    from(zipTree('build/distributions/myZip-1.0.zip'))\n    // 指定打包后文件的输出目录\n    destinationDirectory = file('build/libs')\n}\n\ntask tarTree(type: Tar) {\n    // 指定打包的源文件，这里使用tarTree()函数来展开一个Tar文件作为打包的源\n    from(tarTree('build/distributions/myTar-1.0.tar'))\n    // 指定打包后文件的输出目录\n    destinationDirectory = file('build/libs')\n}\n```\n\n官方文档提供了更多关于 Gradle 文件操作的详细信息，包括如何使用文件路径、文件集合、文件树以及如何处理文件和目录的相对路径等。你可以从以下链接访问官方文档：\n\n- [Gradle 官方文档 - Working With Files](https://docs.gradle.org/current/userguide/working_with_files.html)\n\nGradle 提供了强大的文件操作功能，包括创建和操作归档文件。通过定义任务和使用 Gradle 提供的插件，你可以轻松地将项目打包成所需的格式，并执行各种文件操作。这些功能对于自动化构建和持续集成流程至关重要。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1620630456775032833/3BaLzoGt-gradle-logo.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 3,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1620630456775032833",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-20 19:14:07",
        "updateTime": "2024-04-23 09:37:22",
        "user": {
          "id": "1620630456775032833",
          "planetCode": "3790",
          "userName": "叫我阿杰好了",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1620630456775032833/VD8sEpIL-微信图片_20230523085336.jpg",
          "gender": 1,
          "userProfile": "目前技术社交账号，CSDN JAVA领域优秀创作者，阿里云专家博主。\n微信公众号：叫我阿杰好了",
          "userRole": "vip",
          "interests": [
            "资源",
            "Java",
            "GitHub",
            "面试题"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 3,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": "https://blog.csdn.net/weixin_53041251?spm=1000.2115.3001.5343",
          "score": 35,
          "coin": 20,
          "followeeNum": 1,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2025-03-12 23:57:24",
          "lastLoginTime": null,
          "createTime": "2023-02-01 11:49:45",
          "updateTime": "2024-04-20 17:19:53"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1781610769855569921",
        "title": "Gradle 进阶学习 之 Task",
        "description": "Task就像是Gradle项目中的小小机器人，每个机器人都有特定的工作要做，而且它们还可以根据项目的需要调整自己的工作方式。通过组合不同的Task，你可以构建起复杂的构建流程。",
        "content": "# 1、项目的生命周期\n\nGradle 项目的生命周期分为三大阶段: Initialization -> Configuration -> Execution. 每个阶段都有自己的职责。\n\n想象一下，你正在制作一个大型的乐高城堡。在这个过程中，你需要做三件事：\n\n1. **初始化阶段**：这就像是准备搭建乐高城堡的工具和材料。在Gradle中，这个阶段包括两个小步骤：\n   - **执行Init Script**：这就像是设置乐高城堡的搭建规则，比如决定使用哪些颜色的乐高块，或者设定一些通用的搭建技巧。例如:  配置内部的仓库信息（如公司的 maven 仓库信息）；一些全局属性；用户名及密码信息\n   - **执行Setting Script**：这一步更加重要，它决定了哪些乐高块（项目模块）会参与到城堡的搭建中。\n2. **配置阶段**：这个阶段就像是开始搭建乐高城堡。你会按照图纸（build.gradle文件）上的指示，一块一块地搭建乐高块。在Gradle中，这个阶段会根据你的搭建图纸（build.gradle脚本）来创建任务（task），然后这些任务会形成一个有序的任务网络，确保每个任务都能按照正确的顺序完成。\n3. **执行阶段**：最后，当你的乐高城堡搭建图纸和所有乐高块都准备好了，这个阶段就是开始动手搭建的时候了。Gradle会按照之前创建的任务网络，一步步地完成每个任务，直到整个项目构建完成。\n\n# 2、settings 文件\n\n首先对 settings 文件的几点说明：\n\n1. **作用**：这个文件就像是项目构建的“入门手册”，它告诉我们哪些部分（工程）需要被包含进来一起构建。\n\n2. **工程树**：在Gradle中，工程树就像是一棵大树，有主干（主工程）和分支（子工程），这与Maven中的项目和模块概念相似。\n\n3. **内容**：settings文件里主要记录了项目的名字，以及它包含的所有子项目的名字。\n\n4. **位置**：这个文件必须放在项目的最顶层目录，也就是根工程目录下。\n\n5. **命名**：它的名字是固定的，叫做`settings.gradle`，不能随意更改。\n\n6. **实例对应**：settings文件对应着Gradle中的一个特定实例（`org.gradle.api.initialization.Settings`），每个项目只有一个这样的文件。\n\n7. **关注点**：作为开发者，我们主要关注文件中的`include`方法，它用来添加子项目。通过使用相对路径（例如`:子项目名`）来引入这些子项目。\n\n8. **识别与包含**：只有当子项目在settings文件中被配置后，Gradle才能识别它们，进而在构建过程中将它们包含进来。下面是一个简单的例子：\n\n```groovy\n// 设置根项目的名称\nrootProject.name = 'root' \n// 添加子项目到构建中\ninclude 'subject01' \ninclude 'subject02' \ninclude 'subject03' \n// 如果子项目下还有更细分的项目，也可以这样添加\ninclude 'subject01:subproject011' \ninclude 'subject01:subproject012'\n```\n\n好的，让我们用更通俗的语言来解释一下什么是Gradle中的Task。\n\n# 3、Task\n\n1. **项目组成**：在Gradle中，项目是由一系列的Task（任务）组成的。每个Task代表一个具体的工作单元。\n\n2. **独立执行过程**：每个Task都是一个独立的执行过程，意味着它有特定的开始和结束。这些过程可以是：\n   - 编译Java源代码\n   - 拷贝文件到指定位置\n   - 打包应用程序成Jar文件\n   - 执行系统命令，比如运行测试或者部署应用\n\n3. **读取和设置属性**：Task不仅可以执行操作，还可以读取和修改Project（项目）的属性（Property）。这允许Task根据配置的不同来改变其行为，从而更加灵活。\n\n简而言之，Task就像是Gradle项目中的小小机器人，每个机器人都有特定的工作要做，而且它们还可以根据项目的需要调整自己的工作方式。通过组合不同的Task，你可以构建起复杂的构建流程。\n\n## 3.1 任务入门\n\n可参考官方文档：https://docs.gradle.org/current/userguide/tutorial_using_tasks.html\n\n在Gradle中，任务（Task）是构建过程中执行工作的单元。每个任务可以包含特定的行为，比如执行某些命令或脚本。理解任务的配置和执行阶段对于掌握Gradle的使用至关重要。\n\n1. **任务配置**：任务的配置是在配置阶段完成的，这意味着你会在这个阶段定义任务的行为，例如添加动作（actions）到任务中。\n\n2. **执行命令**：一旦配置好，你可以通过Gradle命令行工具执行任务。例如，如果你有一个名为`A`的任务，你可以在任务所在的目录下运行`gradle A`来执行它。\n\n3. **配置段和行为**：\n    - **配置段**：这是在配置阶段执行的，主要用于设置任务的属性和依赖关系。\n    - **行为**：任务的行为，如`doFirst`和`doLast`，是在执行阶段执行的。`doFirst`中定义的动作会在`doLast`之前执行。\n\n**示例**\n\n假设我们有一个名为`A`的任务，它包含`doFirst`和`doLast`块：\n\n```groovy\ntask A {\n    println \"root taskA\"\n    doFirst {\n        println \"root taskA doFirst\"\n    }\n    doLast {\n        println \"root taskA doLast\"\n    }\n}\n```\n\n![image-20240420144533126](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420144533126.png)\n\n- 当你运行`gradle A`时，Gradle首先进入配置阶段，解析并配置任务`A`。\n- 然后，Gradle进入执行阶段，依次执行任务`A`中的`doFirst`和`doLast`块。\n\n**提示说明**\n\n- **提示 1**：强调任务的配置是在配置阶段完成的，这是Gradle构建生命周期中的一个阶段，用于确定需要执行哪些任务以及它们的配置。\n- **提示 2**：说明`doFirst`和`doLast`是在执行阶段执行的动作，且`doFirst`中的动作会在`doLast`之前执行。\n- **提示 3**：提醒我们区分任务的配置和行为，配置在配置阶段执行，而行为在执行阶段执行。\n\n## 3.2 任务的行为\n\n> 案例如下：doFirst、doLast 两个方法可以在任务内部定义，也可以在任务外部定义。\n\n![image-20240420144939525](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420144939525.png)\n\n![image-20240420150156298](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420150156298.png)\n\n**底层原理分析**：\n\n在Gradle中，任务的行为是通过一系列动作（actions）来定义的。这些动作按照特定的顺序执行，确保了任务的逻辑可以按照预期的方式运行。以下是对底层原理的分析，以及对`doFirst`和`doLast`方法的说明。\n\n动作列表（Action List）\n\n1. **动作列表初始化**：每个任务都有一个动作列表，最初这个列表是空的。\n\n2. **添加动作**：当你为任务定义动作（通过闭包传递给任务的构造函数或者使用`doLast`方法）时，这个动作被添加到动作列表的末尾。\n\n3. **`doFirst`方法**：使用`doFirst`添加的动作会被放置在动作列表的开头。这意味着`doFirst`动作将最先执行。\n\n4. **`doLast`方法**：使用`doLast`添加的动作会被追加到动作列表的末尾。这意味着`doLast`动作将在其他动作之后执行。\n\n5. **执行顺序**：最终，动作列表按照`doFirst` -> 任务自身定义的动作（通常称为`doSelf`）-> `doLast`的顺序执行。\n\n**提示说明**\n\n- **提示 1**：在Gradle 5.x版本之后，使用左移操作符（`<<`）来添加任务动作的方式已经被废弃。这意味着你不能再使用如下语法来添加任务动作：\n\n```groovy\ntask hello << {\n    println 'Hello world!'\n}\n```\n\n  取而代之的是，你应该使用`doLast`或`doFirst`方法来添加动作。\n\n**动作顺序的重要性**\n\n理解任务动作的顺序对于控制任务的执行流程至关重要。例如，你可能需要在编译之前先进行代码检查，或者在打包之后执行测试。通过`doFirst`和`doLast`，你可以灵活地控制这些依赖关系，确保任务按照正确的顺序执行。\n\n**总结**\n\nGradle的任务系统通过动作列表提供了强大的灵活性，允许开发者精确控制任务的执行逻辑。随着Gradle版本的更新，一些旧的语法可能会被新的、更明确的方法所取代，因此，保持对Gradle最佳实践和最新版本的了解是非常重要的。\n\n## 3.3 任务的依赖方式\n\nTask 之间的依赖关系可以在以下几部分设置：\n\n**方式一：参数方式依赖**：\n\n![image-20240420150717922](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420150717922.png)\n\n**方式二：内部依赖**\n\n![image-20240420150904089](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420150904089.png)\n\n**方式三：外部依赖**\n\n**当然：task也支持跨项目依赖**\n\n![image-20240420151711128](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420151711128.png)\n\n> ### 拓展1：无依赖关系的任务执行顺序\n>\n> 当一个任务依赖多个任务时，如果这些被依赖的任务之间没有指定依赖关系，Gradle会根据任务的有向无环图（DAG）来决定执行顺序。在这种情况下：\n>\n> - **执行顺序**：Gradle会尝试以一种效率最高的方式执行这些任务，但如果没有特定的依赖关系，任务的执行顺序可能不是完全确定的。也就是说，两个没有直接依赖关系的任务可能会以任意顺序执行，因为它们是独立的。\n>\n> - **无影响**：尽管执行顺序可能是随机的，但这通常不会影响最终的构建结果，因为这些任务是相互独立的。\n>\n> ### 拓展2：重复依赖的任务执行\n>\n> 在Gradle中，如果一个任务被重复依赖，Gradle会确保该任务只执行一次，即使它被多个任务依赖：\n>\n> - **执行一次**：无论一个任务被依赖多少次，Gradle都会保证这个任务在当前的构建过程中只执行一次。这是通过内部的缓存机制来实现的，确保了构建的效率。\n>\n> - **依赖传递**：在依赖图中，如果任务A依赖任务B，而任务B又依赖任务C，那么执行任务A时，任务C也会被执行，但任务C只会执行一次，即使它被B和A间接或直接依赖。\n>\n> ### 依赖关系的重要性\n>\n> 理解任务依赖关系对于构建复杂的项目至关重要。依赖关系不仅决定了任务的执行顺序，还影响了构建的效率和结果。通过合理地设置依赖关系，可以确保项目按照正确的顺序构建，同时避免不必要的重复工作。\n>\n> ### 总结\n>\n> Gradle的任务依赖系统提供了灵活性和效率，允许开发者定义复杂的构建流程。了解任务依赖的执行顺序和重复依赖的处理方式，可以帮助开发者更好地控制构建过程，提高构建的可预测性和性能。\n\n## 3.4 任务执行\n\n> 任务执行语法：**gradle [taskName...] [--option-name...]。**\n\n### 3.4.1 常见的任务 *\n\n| 命令                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| `gradle build`                                               | 构建项目，执行编译、测试、打包等操作。                       |\n| `gradle run`                                                 | 运行一个服务。需要`application`插件支持，并且指定了主启动类。 |\n| `gradle clean`                                               | 清除当前项目的`build`目录。                                  |\n| `gradle init`                                                | 初始化Gradle项目。                                           |\n| `gradle wrapper`                                             | 生成`wrapper`文件夹。                                        |\n| `gradle wrapper --gradle-version=<version>`                  | 升级wrapper到指定的Gradle版本号。                            |\n| `gradle wrapper --gradle-version <version> --distribution-type all` | 升级wrapper到指定的Gradle版本号，并关联源码。                |\n\n请根据需要替换`<version>`为实际的Gradle版本号。例如，使用`gradle wrapper --gradle-version=4.4`将wrapper升级到Gradle 4.4版本。\n\n### 3.4.2 项目报告相关任务\n\n| 命令                                 | 描述                                                |\n| ------------------------------------ | --------------------------------------------------- |\n| `gradle projects`                    | 列出所选项目及其子项目列表，以层次结构形式显示。    |\n| `gradle tasks`                       | 列出所选项目（当前project）的已分配给任务组的任务。 |\n| `gradle tasks --all`                 | 列出所选项目的所有任务。                            |\n| `gradle tasks --group=\"build setup\"` | 列出所选项目中指定分组（如\"build setup\"）中的任务。 |\n| `gradle help --task someTask`        | 显示某个任务（如`someTask`）的详细信息。            |\n| `gradle dependencies`                | 查看整个项目的依赖信息，以依赖树的方式显示。        |\n| `gradle properties`                  | 列出所选项目的属性列表。                            |\n\n请注意，`someTask`应替换为您想要获取帮助信息的实际任务名称。这些命令可以帮助您更好地管理和理解Gradle项目的结构、任务和依赖。\n\n### 3.4.3 调试相关选项\n\n| 选项                                    | 描述                                               |\n| --------------------------------------- | -------------------------------------------------- |\n| `-h`, `--help`                          | 查看帮助信息。                                     |\n| `-v`, `--version`                       | 打印Gradle、Groovy、Ant、JVM和操作系统的版本信息。 |\n| `-S`, `--full-stacktrace`               | 打印所有异常的完整（非常详细）堆栈跟踪信息。       |\n| `-s`, `--stacktrace`                    | 打印用户异常的堆栈跟踪（例如编译错误）。           |\n| `-Dorg.gradle.daemon.debug=true`        | 调试Gradle守护进程。                               |\n| `-Dorg.gradle.debug=true`               | 调试Gradle客户端（非守护进程）进程。               |\n| `-Dorg.gradle.debug.port=(port number)` | 指定启用调试时要侦听的端口号，默认值为5005。       |\n\n在使用这些选项时，您需要将`(port number)`替换为实际想要指定的端口号。这些选项对于调试和获取Gradle运行时的详细信息非常有用。\n\n### 3.4.4 性能选项\n\n> 在gradle.properties 中指定这些选项中的许多选项，因此不需要命令行标志.\n\n| 选项                                | 描述                                                         |\n| ----------------------------------- | ------------------------------------------------------------ |\n| `--build-cache`, `--no-build-cache` | 启用或禁用尝试重用先前版本的输出。默认关闭(off)。            |\n| `--max-workers`                     | 设置Gradle可以使用的工作线程数。默认值是处理器的数量。       |\n| `--parallel`, `--no-parallel`       | 启用或禁用并行执行项目。有关此选项的限制，请参阅并行项目执行的文档。默认关闭(off)。 |\n\n这些选项可以帮助您优化Gradle构建的性能，通过调整构建缓存的使用、工作线程的数量以及是否并行执行项目来提升构建效率。\n\n### 3.4.5 守护进程选项\n\n| 选项                                       | 描述                                                         |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| `--daemon`, `--no-daemon`                  | 启用或禁用使用Gradle守护进程运行构建。默认是启用(on)。       |\n| `--foreground`                             | 在前台进程中启动Gradle守护进程。                             |\n| `-Dorg.gradle.daemon.idletimeout=(毫秒数)` | 设置Gradle守护进程在空闲指定毫秒数后自动停止。默认值为10800000毫秒（3小时）。 |\n\n在使用这些选项时，您需要将`(毫秒数)`替换为实际想要指定的毫秒数值。这些选项对于控制Gradle守护进程的行为和性能优化非常有用。\n\n### 3.4.6 日志选项\n\n| 选项                                                         | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| `-Dorg.gradle.logging.level=(quiet,warn,lifecycle,info,debug)` | 通过Gradle属性设置日志记录级别，可选级别包括quiet, warn, lifecycle, info, debug。 |\n| `-q`, `--quiet`                                              | 将日志级别设置为quiet，只能记录错误信息。                    |\n| `-w`, `--warn`                                               | 将日志级别设置为warn。                                       |\n| `-i`, `--info`                                               | 将日志级别设置为info。                                       |\n| `-d`, `--debug`                                              | 将日志级别设置为debug，包括正常的堆栈跟踪信息。              |\n\n在使用这些选项时，您需要将`(quiet,warn,lifecycle,info,debug)`替换为实际想要指定的日志级别。这些选项可以帮助您根据需要调整Gradle的输出信息量，以便更好地进行问题诊断或减少输出干扰。\n\n### 3.4.7 其它 * \n\n| 命令/选项                    | 描述                                                 |\n| ---------------------------- | ---------------------------------------------------- |\n| `-x`, `--exclude-task`       | 排除指定的任务，不执行该任务。                       |\n| `gradle -x test clean build` | 构建项目时排除`test`任务，然后执行`clean`和`build`。 |\n| `--rerun-tasks`              | 强制执行任务，忽略up-to-date检查。                   |\n| `gradle build --rerun-tasks` | 强制重新构建项目，忽略缓存。                         |\n| `--continue`                 | 忽略前面失败的任务，继续执行构建。                   |\n| `gradle build --continue`    | 即使某些任务失败，也继续构建过程。                   |\n| `gradle init --type pom`     | 将Maven项目转换为Gradle项目（在根目录执行）。        |\n| `gradle [taskName]`          | 执行指定的自定义任务。                               |\n\n这些命令和选项能够提供构建过程中的灵活性和控制力，允许用户根据需要排除任务、强制重新执行任务、在遇到错误时继续构建，或者将现有Maven项目迁移到Gradle。\n\n\n\n更详细请参考官方文档: https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_executing_tasks\n\n\n\n> 拓展：任务名缩写\n>\n> 1. **驼峰式命名风格**：在编程中，驼峰式命名风格是一种常见的命名约定，其中每个单词的首字母大写，不使用下划线或连字符。例如，`connectTask` 是一个遵循驼峰命名法的变量名。\n>\n> 2. **任务名缩写**：Gradle 允许你使用任务名的缩写来执行任务，这使得执行长任务名更加方便。缩写应该是唯一的，以便 Gradle 能够正确地识别要执行的任务。\n>\n>    - 例如，如果有一个名为 `connectTask` 的任务，你可以使用缩写 `cT` 来执行它，通过命令 `gradle cT`。\n>\n> 3. **执行任务**：在命令行中，你可以使用缩写的名称来告诉 Gradle 你想要运行哪个任务。\n>\n> 拓展 1：Gradle 指令本质\n>\n> 1. **基于任务的操作**：Gradle 的所有指令本质上都是对任务的操作。无论是编译代码、测试、打包还是部署，这些操作都是通过执行定义好的任务来完成的。\n>\n> 2. **任务的依赖性**：任务可以相互依赖，这意味着某些任务只有在其他任务完成后才能执行。这种依赖性定义了项目的构建顺序。\n>\n> 3. **灵活性和自动化**：通过任务和它们的依赖关系，Gradle 能够自动化复杂的构建过程，提供了一种灵活的方式来管理和执行项目中的各种构建步骤。\n>\n> **拓展 2**：gradle 默认各指令之间相互的依赖关系：\n>\n> ![image-20240420154243499](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420154243499.png)\n>\n> 相关解释：\n>\n> ![image-20240420154257630](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420154257630.png)\n\n## 3.5 任务定义方式\n\n在Gradle中，定义任务是构建自动化流程的基础。你可以通过几种不同的方式定义任务，每种方式都适用于不同的场景。以下是对提到的任务定义方式的详细解释：\n\n**通过`Project`的`task()`方法**\n\n1. **基本用法**：使用`Project`对象的`task()`方法可以定义一个新任务。你可以传递一个字符串作为任务名称，以及一个闭包来定义任务的行为。\n\n   ```groovy\n   task('A') {\n       println \"taskA...\"\n   }\n   ```\n\n2. **闭包作为参数**：闭包可以作为`task()`方法的最后一个参数，用来指定任务的行动。\n\n   ```groovy\n   task('B') {\n       println \"taskB...\"\n   }\n   ```\n\n3. **省略方法括号**：在Groovy语言中，当方法的最后一个参数是一个闭包，你可以省略该方法的括号，使得代码更加简洁。\n\n   ```groovy\n   task 'C' {\n       println \"taskC...\"\n   }\n   ```\n\n**通过`tasks`对象的`create`或`register`方法**\n\n1. **使用`create`方法**：`tasks`对象的`create`方法可以用来创建一个新的任务，它接受一个任务名称和一个闭包作为参数。\n\n   ```groovy\n   tasks.create('E') {\n       println \"taskE...\"\n   }\n   ```\n\n2. **使用`register`方法**：`register`方法与`create`方法类似，但它执行的是延迟创建。这意味着任务只有在实际需要执行时才会被创建。\n\n   ```groovy\n   tasks.register('F') {\n       println \"taskF...\"\n   }\n   ```\n\n3. **注解**：`register`方法通常用于那些可能不会总是执行的任务，比如某些仅在特定条件下需要运行的配置任务。\n\n**使用Map来定义任务**\n\n1. **Map属性**：你还可以使用一个Map来定义任务，其中Map中的`action`键可以设置为一个闭包，用来指定任务的行为。\n\n   ```groovy\n   def map = new HashMap<String, Object>()\n   map.put(\"action\", { println \"taskD..\" })\n   task(map, \"D\")\n   ```\n\nGradle提供了多种定义任务的方法，每种方法都有其使用场景。`task()`方法是最直观的，适合简单任务的定义。而`tasks.create`和`tasks.register`方法提供了更多的灵活性，特别是当任务的创建需要一些条件判断或者延迟初始化时。使用Map定义任务则是一种更高级的技巧，可以在某些复杂的构建脚本中见到。了解这些不同的方法可以帮助你更好地编写和维护Gradle构建脚本。\n\n当然：我们也可以在定义任务的同时指定任务的属性，具体属性有：\n\n1. **type**\n   - **描述**：这个配置项允许你指定任务的类型，即基于一个已存在的任务类型来创建新任务，类似于在面向对象编程中的类继承。当你想要创建一个具有特定行为的任务时，你可以指定一个已有的任务类作为其类型。\n   - **默认值**：`DefaultTask`，这是Gradle中所有任务的基类。\n\n2. **overwrite**\n   - **描述**：这个配置项决定当你使用`type`配置项创建一个同名的新任务时，是否覆盖已存在的任务。如果设置为`true`，则新任务会替换掉同名的旧任务。\n   - **默认值**：`false`，意味着同名任务不会覆盖，除非明确设置。\n\n3. **dependsOn**\n   - **描述**：这个配置项用来指定任务的依赖关系。一个任务可以依赖一个或多个其他任务，确保在执行当前任务之前，所依赖的任务已经完成。\n   - **默认值**：`[]`，即空数组，表示没有依赖。\n\n4. **action**\n   - **描述**：这个配置项允许你为任务添加一个动作（Action），可以是一个实现了`Action<T>`接口的实例，或者是一个闭包。这个动作定义了任务执行时的具体行为。\n   - **默认值**：`null`，表示没有指定动作。\n\n5. **description**\n   - **描述**：这个配置项用来为任务提供一个描述性的文本，这个文本可以用于帮助理解任务的作用，尤其是在列出所有可用任务时。\n   - **默认值**：`null`，表示没有描述。\n\n6. **group**\n   - **描述**：这个配置项用于将任务分组。通过分组，可以在列出所有任务时更好地组织和展示任务，也可以通过组名来执行一组任务。\n   - **默认值**：`null`，表示没有分组。\n\n**使用示例**\n\n```groovy\n/**\n * 定义一个名为B的任务。\n * 该任务具有以下特点：\n * 1. 依赖于根工程下名为gradle001的项目的任务A，实现了跨项目依赖。\n * 2. 在执行任务时，首先会打印'Executing myTask'。\n * 3. 任务具有自定义的描述和所属组信息。\n */\ntask B {\n    // 依赖根工程下的任务A，实现跨项目依赖\n    dependsOn(\":gradle001:A\") \n\n    // 定义任务执行前的动作，这里打印一条信息\n    doFirst { \n        println 'Executing myTask'\n    }\n\n    // 设置任务的描述信息\n    description = 'This is a custom task' \n\n    // 设置任务所属的组\n    group = 'jie' \n}\n\n```\n\n![image-20240420155801691](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420155801691.png)\n\n## 3.6 任务类型\n\nGradle 提供了一系列预定义的任务类型，这些任务类型封装了常见的构建操作，使得用户不需要从头开始编写复杂的脚本。通过指定任务的类型，你可以利用 Gradle 提供的内置功能来执行特定的构建任务。以下是一些常见的内置任务类型及其作用：\n\n| 任务类型                 | 作用                                             |\n| ------------------------ | ------------------------------------------------ |\n| Delete                   | 删除文件或目录。                                 |\n| Copy                     | 将文件复制到目标目录中，支持重命名和筛选文件。   |\n| CreateStartScripts       | 创建启动脚本，以便可以在不同操作系统上运行项目。 |\n| Exec                     | 执行命令行进程。                                 |\n| GenerateMavenPom         | 生成 Maven 模块描述符（POM）文件。               |\n| GradleBuild              | 执行 Gradle 构建。                               |\n| Jar                      | 组装 JAR 归档文件。                              |\n| JavaCompile              | 编译 Java 源文件。                               |\n| Javadoc                  | 为 Java 类生成 HTML API 文档。                   |\n| PublishToMavenRepository | 将 MavenPublication 发布到 Maven 仓库。          |\n| Tar                      | 组装 TAR 存档文件。                              |\n| Test                     | 执行 JUnit (3.8.x、4.x 或 5.x) 或 TestNG 测试。  |\n| Upload                   | 将配置的构件上传到一组仓库。                     |\n| War                      | 组装 WAR 档案。                                  |\n| Zip                      | 组装 ZIP 归档文件，默认情况下会压缩 ZIP 的内容。 |\n\n**使用内置任务类型**\n\n要使用这些内置任务类型，你只需在定义任务时指定 `type` 参数。例如，如果你想要创建一个删除特定目录的任务，可以这样做：\n\n```groovy\ntask clean(type: Delete) {\n    delete 'path/to/directory'\n}\n```\n\n这将创建一个名为 `clean` 的任务，使用 `Delete` 任务类型来删除指定的目录。\n\n> Gradle 的内置任务类型提供了一种快速、简便的方式来执行常见的构建任务，无需编写大量的自定义脚本。通过使用这些类型，你可以减少构建脚本的复杂性，同时提高构建过程的可读性和可维护性。\n\n更详细的 gradle 自带 Task 类型，请参考官方文档: https://docs.gradle.org/current/dsl/index.html\n\n官方文档在给出这些任务类型的时候，同时给出了案例代码，可以点进去上述官网地址中的某个类型中观看\n\n![image-20240420160305645](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420160305645.png)\n\n## 3.7 任务的执行顺序\n\n在Gradle中，确实有几种方法可以指定任务（Task）的执行顺序。以下是这三种方法的详细说明：\n\n### 1. `dependsOn` 强依赖方式\n\n`dependsOn` 是一种显式指定任务依赖关系的方法。当你设置一个任务的 `dependsOn` 属性时，Gradle 会在执行当前任务之前确保所依赖的任务已经完成。\n\n```groovy\ntask taskOne {\n    doLast {\n        println 'Executing taskOne'\n    }\n}\n\ntask taskTwo {\n    dependsOn taskOne\n    doLast {\n        println 'Executing taskTwo'\n    }\n}\n```\n\n在这个例子中，`taskTwo` 明确依赖于 `taskOne`，因此 `taskOne` 将先于 `taskTwo` 执行。\n\n### 2. 通过任务输入输出\n\nGradle 也允许你通过定义任务的输入和输出文件来指定执行顺序。Gradle 会根据这些文件的存在与否来决定是否需要执行任务。如果任务的输出文件不存在于文件系统中，或者输入文件自上次任务执行后发生了变化，Gradle 将重新执行该任务。\n\n```groovy\ntask compileJava {\n    // 定义任务的输出目录\n    outputs.dir 'build/classes'\n    doLast {\n        println 'Compiling Java code'\n    }\n}\n\ntask packageApp {\n    // 定义任务的输入目录，即 compileJava 任务的输出目录\n    inputs.dir 'build/classes'\n    doLast {\n        println 'Packaging the application'\n    }\n}\n```\n\n在这个例子中，`packageApp` 任务依赖于 `compileJava` 任务的输出目录，因此 Gradle 会先执行 `compileJava`，然后再执行 `packageApp`。\n\n### 3. 通过 API 指定执行顺序\n\nGradle 提供了 Task Ordering API，允许你更细致地控制任务的执行顺序。你可以使用 `mustRunAfter` 或者 `finalizedBy` 方法来指定任务的相对顺序。\n\n```groovy\ntask taskA {\n    doLast {\n        println 'Executing taskA'\n    }\n}\n\ntask taskB {\n    mustRunAfter taskA // taskB 必须在 taskA 之后执行\n    doLast {\n        println 'Executing taskB'\n    }\n}\n\ntask taskC {\n    finalizedBy taskB // taskC 完成后，taskB 将被执行\n    doLast {\n        println 'Executing taskC'\n    }\n}\n```\n\n在这个例子中，`taskB` 使用 `mustRunAfter` 确保它在 `taskA` 之后执行，而 `taskC` 使用 `finalizedBy` 确保在 `taskC` 完成后执行 `taskB`。\n\n### 总结\n\n这三种方法提供了不同的层面来控制任务的执行顺序，从简单的显式依赖到基于文件的依赖，再到更复杂的 API 控制，Gradle 为用户提供了灵活的方式来定义和管理构建过程中的任务顺序。\n\n## 3.8 动态分配任务\n\nGradle 的灵活性和强大功能确实不仅限于定义单一任务，它还允许进行更高级的操作，比如在构建脚本中动态生成任务。以下是对您提供的示例和概念的解释：\n\n### 3.8.1 在循环中注册多个任务\n\n通过使用 Groovy 语言的闭包和循环结构，Gradle 允许你在构建脚本中动态地注册多个任务。这种方式非常适合当你需要根据某些条件或循环生成的任务集合时使用。\n\n```groovy\n4.times { counter ->\n    tasks.register(\"task$counter\") {\n        doLast {\n            println \"I'm task number $counter\"\n        }\n    }\n}\n```\n\n在这个例子中，使用 `4.times` 循环四次，每次迭代都注册一个新任务，任务名根据循环的计数器动态生成。\n\n### 3.8.2 动态添加依赖项\n\n一旦任务被注册，你可以通过 Gradle 提供的 Task API 在运行时动态地修改任务的行为，包括添加依赖项。这与像 Ant 这样的传统构建工具不同，后者不提供这种运行时修改的能力。\n\n```groovy\ntasks.named('task0') { it.dependsOn('task2', 'task3') }\n```\n\n在这个例子中，我们通过 `tasks.named` 方法获取对任务 `task0` 的引用，并使用 `dependsOn` 方法动态地给 `task0` 添加了依赖，指定 `task2` 和 `task3` 必须在 `task0` 执行之前完成。\n\n### 3.8.3 构建顺序的确保\n\n通过上述动态添加依赖的方式，Gradle 确保了 `task2` 和 `task3` 会在 `task0` 之前执行，因为 `task0` 显式地声明了对它们依赖。这种依赖关系的声明是 Gradle 构建系统正确执行任务顺序的关键。\n\n### 3.8.4 总结\n\nGradle 的动态任务注册和 API 使得构建脚本更加灵活和强大。通过循环和 API 动态地创建任务以及添加依赖，Gradle 允许开发者根据构建逻辑的需要，以编程方式生成复杂的任务网络。这种灵活性是 Gradle 成为现代自动化构建首选工具之一的原因之一。\n\n## 3.9 任务的关闭与开启\n\n在Gradle中，每个任务都有一个`enabled`属性，用来控制任务是否应该被执行。这个属性默认值为`true`，意味着任务是启用的，将按照正常的流程执行其动作。如果将`enabled`设置为`false`，则任务将被禁用，不会执行任何动作，并且在构建过程中会标记为“跳过”。\n\n以下是如何设置任务的`enabled`属性的示例：\n\n```groovy\ntask disableMe {\n    doLast {\n        println 'This task is Executing...'\n    }\n    // 直接设置任务为开启（启用），这是默认行为，所以实际上下面的enabled(true)是可选的\n    enabled true\n    \n    // 可以通过闭包的方式动态设置任务的启用状态\n    enabled = { false } // 这样设置任务将被禁用，不会执行\n}\n\n// 另一种设置任务禁用的方式\ndisableMe.enabled = false // 这样也可以设置任务关闭（禁用）\n```\n\n在这个例子中，`disableMe`任务被创建并定义了要执行的动作。然后通过两种不同的方法展示了如何禁用任务：\n\n1. 使用闭包和`enabled`属性，将任务设置为禁用。\n2. 直接在任务对象上使用`enabled`属性，将其设置为`false`。\n\n禁用的任务在构建过程中不会被执行，这可以用于条件性地跳过某些任务，例如在某些环境或配置下不需要执行测试任务时。\n\n### 3.9.1 总结\n\nGradle的任务`enabled`属性提供了一种简单而直接的方式来控制任务的执行。通过这个属性，可以根据构建的不同需求动态地启用或禁用任务，增加了构建流程的灵活性。\n\n## 3.10 任务的超时\n\n在Gradle中，`timeout`属性允许你为任务设置一个执行时间限制。如果任务的执行时间超过了这个限制，Gradle会中断该任务的执行，并将任务标记为失败。这个过程称为超时。\n\n### 3.10.1 超时行为\n\n- **任务中断**：当任务达到超时时间时，Gradle会尝试中断执行该任务的线程。\n- **失败标记**：超时的任务会被标记为失败。\n- **终结器任务**：即使某个任务因为超时而失败，Gradle的终结器（finalizer）任务仍然会执行。终结器任务通常用于清理工作，比如删除临时文件。\n- **继续执行**：如果使用了`--continue`命令行选项，即使前面的任务失败，Gradle也会继续执行后续的任务。\n\n### 3.10.2 示例解析\n\n```groovy\ntask a {\n    doLast {\n        Thread.sleep(1000) // 使线程休眠1秒\n        println \"当前任务a执行了\"\n    }\n    timeout = Duration.ofMillis(500) // 设置超时为500毫秒\n}\n\ntask b {\n    doLast {\n        println \"当前任务b执行了\"\n    }\n}\n```\n\n- **任务a**：设置了超时时间为500毫秒，但它实际休眠了1000毫秒，因此会超时。\n\n### 3.10.3 控制台命令测试\n\n- **命令1**：`gradle a b`，当你执行这个命令时，任务a会因为超时而失败，并且由于默认行为，Gradle会停止执行后续的任务b。\n\n- **命令2**：`gradle a b --continue`，使用`--continue`选项后，即使任务a超时失败，Gradle也会继续执行任务b。\n\n### 3.10.4 不响应中断的任务\n\n需要注意的是，如果任务在执行时不响应中断（例如，它在执行一个阻塞操作但没有检查中断信号），那么超时机制可能无法正常工作。\n\n### 3.10.5 总结\n\nGradle的`timeout`属性提供了一种机制，可以避免任务执行时间过长。通过合理设置超时，你可以确保构建过程不会因为某个任务的长时间挂起而停滞不前。同时，`--continue`选项提供了在面对失败时继续执行的能力，这对于执行多个任务的构建流程特别有用。\n\n##  3.11 任务的查找 \n\n在Gradle中，查找任务是一项常见的操作，特别是在复杂的构建脚本中，你可能需要对特定的任务进行操作或者配置。以下是几种常用的任务查找方法：\n\n### 3.11.1 根据任务名查找\n\n1. `tasks.findByName(String name)`：根据指定的任务名查找任务。如果找到了任务，返回对应的任务对象；如果没有找到，返回`null`。\n\n2. `tasks.getByName(String name)`：同样根据指定的任务名获取任务。但是，如果任务不存在，这个方法会抛出一个`UnknownTaskException`异常。\n\n示例\n\n![image-20240420162639566](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420162639566.png)\n\n### 3.11.2 根据任务路径查找\n\n1. `tasks.findByPath(String path)`：根据任务的路径查找任务。任务路径通常是相对于项目根目录的路径，例如`:atguigu`表示当前项目的`atguigu`任务。\n\n2. `tasks.getByPath(String path)`：根据任务路径获取任务对象。如果任务不存在，会抛出`UnknownTaskException`异常。\n\n示例\n\n![image-20240420162802043](https://yiqiezonghuiguiyupingdan.oss-cn-hangzhou.aliyuncs.com/blw210/2024/image-20240420162802043.png)\n\n### 3.11.3 执行结果\n\n当你执行`gradle atguigu`命令时，Gradle会按照你添加动作的顺序执行它们。在这个例子中，由于`getByPath`方法添加的动作会被优先执行，其次是`findByPath`，然后是`getByName`和`findByName`。\n\n- 使用`findByName`和`findByPath`方法时，由于它们返回`null`而不是抛出异常，你可以安全地使用`?.`操作符来为可能为`null`的任务添加动作。\n- 动作添加的顺序很重要，Gradle会按照你添加动作的顺序来执行它们。\n\n通过这些查找方法，你可以灵活地在构建脚本中引用和操作任务，从而实现更复杂的构建逻辑。\n\n## 3.12 任务的规则\n\nGradle 提供了一个非常有用的功能，称为“任务规则（Task Rules）”，它允许你在运行一个不存在的任务时执行自定义逻辑，而不是直接报错。通过添加任务规则，你可以改进 Gradle 的行为，使其在找不到指定任务时提供一个更友好的错误消息，或者动态创建任务。\n\n### 3.12.1 添加任务规则\n\n以下是如何使用 `tasks.addRule` 方法添加一个任务规则的示例：\n\n```groovy\ntask hello {\n    doLast {\n        println 'hello 阿杰的粉丝们'\n    }\n}\n\ntasks.addRule(\"对该规则的一个描述，便于调试、查看等\") {\n    String taskName ->\n    if (!tasks.findByName(taskName)) {\n        task(taskName) {\n            doLast {\n                println \"该${taskName}任务不存在，请查证后再执行\"\n            }\n        }\n    }\n}\n```\n\n在这个例子中，我们定义了一个规则，它会检查尝试执行的任务是否存在。如果不存在，它不会报错，而是创建一个新的任务并提供一条提示信息。\n\n### 3.12 .2 测试任务规则\n\n使用以下命令进行测试：\n\n```shell\ngradle abc hello\n```\n\n在这个测试中，`abc` 任务不存在，但由于我们添加了上述规则，Gradle 不会报错，而是会打印出我们定义的提示信息。之后，Gradle 会继续执行存在的 `hello` 任务。\n\n### 3.12.3 动态创建任务\n\nGradle 的任务规则不仅可以用于提供更好的错误消息，还可以用于动态创建任务。例如，你可以编写一个规则，根据某些条件动态创建任务，或者为一组相似的任务提供一个模板。\n\n### 3.12.4 总结\n\n任务规则是 Gradle 提供的一个强大功能，它允许你以更灵活和用户友好的方式处理未知任务的执行。通过合理利用任务规则，你可以改进构建脚本的健壮性，提供更清晰的错误消息，或者实现复杂的动态任务创建逻辑。\n\n## 3.13 任务的 onlyIf 断言\n\n在 Gradle 中，断言（assertion）是一种确保某些条件为真的方法。在构建自动化中，这可以用于确保在执行任务之前满足特定的先决条件。\n\n`Task` 对象的 `onlyIf` 方法允许你提供一个闭包，这个闭包将作为决定任务是否执行的条件。如果闭包返回 `true`，则任务将执行；如果返回 `false`，则任务将被跳过。\n\n### 3.13.1 使用 `onlyIf` 的示例\n\n以下是如何使用 `onlyIf` 方法的示例：\n\n```groovy\ntask hello {\n    doLast {\n        println 'hello 阿杰的粉丝们'\n    }\n}\n\n// 使用 onlyIf 来决定是否执行 hello 任务\nhello.onlyIf { !project.hasProperty('fensi') }\n```\n\n在这个例子中，`hello` 任务将检查是否存在一个名为 `fensi` 的属性。如果不存在，`hello` 任务将执行；如果存在，则跳过。\n\n### 3.13.2 测试 `onlyIf` 行为\n\n要测试这个行为，你可以使用 `-P` 命令行选项来为项目添加属性：\n\n```shell\ngradle hello -Pfensi\n```\n\n在这个测试中，由于我们使用 `-Pfensi` 提供了 `fensi` 属性，`hello` 任务将不会执行。\n\n### 3.13.3 使用场景\n\n`onlyIf` 方法可以用于多种场景，例如：\n\n- 仅在某些环境变量设置时执行特定任务。\n- 根据项目属性决定是否运行测试。\n- 条件性地打包或部署应用程序。\n\n### 3.13.4 总结\n\n`onlyIf` 方法为 Gradle 任务的执行提供了条件控制，允许你灵活地根据构建时的上下文决定任务的执行。这种方法可以减少不必要的构建步骤，提高构建的效率和灵活性。\n\n## 3.14 默认任务\n\n在 Gradle 中，当你运行 `gradle` 命令而没有指定具体的任务时，Gradle 会寻找并执行默认任务。默认任务是一组在没有明确指定要执行的任务时被自动执行的任务。\n\n### 3.14.1 设置默认任务\n\n你可以通过两种方式设置默认任务：\n\n1. **全局默认任务**：在 `settings.gradle` 文件中，你可以为整个项目或特定的项目设置默认任务。\n\n2. **项目特定默认任务**：在 `build.gradle` 文件中，你可以为单个项目设置默认任务。\n\n以下是如何设置默认任务的示例：\n\n```groovy\n// 在 build.gradle 文件中设置项目特定的默认任务\ndefaultTasks 'myClean', 'myRun'\n\ntasks.register('myClean') {\n    doLast {\n        println 'Default Cleaning!'\n    }\n}\n\ntasks.register('myRun') {\n    doLast {\n        println 'Default Running!'\n    }\n}\n\ntasks.register('other') {\n    doLast {\n        println \"I'm not a default task!\"\n    }\n}\n```\n\n在这个例子中，`myClean` 和 `myRun` 被设置为默认任务。\n\n### 3.14.2 测试默认任务\n\n当你在命令行运行 `gradle` 而不指定任务时，Gradle 会执行上面设置的默认任务：\n\n```shell\n> gradle -q\n```\n\n执行上述命令，输出结果将是：\n\n```\nDefault Cleaning!\nDefault Running!\n```\n\n这里使用了 `-q` 参数来减少 Gradle 的日志输出，以便更清晰地展示默认任务的执行结果。\n\n### 3.14.3 总结\n\n默认任务的概念使得 Gradle 构建更加灵活和方便。通过设置默认任务，你可以为常用的构建步骤定义快捷方式，从而提高日常构建的效率。这对于快速启动常规的构建流程或为新团队成员提供简单的入门步骤特别有用。\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1620630456775032833/3yXVH1Vo-gradle-logo.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 2,
        "thumbNum": 2,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1620630456775032833",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2024-04-20 17:08:02",
        "updateTime": "2024-04-20 21:04:26",
        "user": {
          "id": "1620630456775032833",
          "planetCode": "3790",
          "userName": "叫我阿杰好了",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1620630456775032833/VD8sEpIL-微信图片_20230523085336.jpg",
          "gender": 1,
          "userProfile": "目前技术社交账号，CSDN JAVA领域优秀创作者，阿里云专家博主。\n微信公众号：叫我阿杰好了",
          "userRole": "vip",
          "interests": [
            "资源",
            "Java",
            "GitHub",
            "面试题"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": 3,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": "https://blog.csdn.net/weixin_53041251?spm=1000.2115.3001.5343",
          "score": 35,
          "coin": 20,
          "followeeNum": 1,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2025-03-12 23:57:24",
          "lastLoginTime": null,
          "createTime": "2023-02-01 11:49:45",
          "updateTime": "2024-04-20 17:19:53"
        },
        "tags": [
          "文章",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "4242",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "531"
  },
  "message": "ok"
}